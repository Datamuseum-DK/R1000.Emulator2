/* THIS FILE IS MACHINE GENERATED by process_kicad_netlists.py */

#include <stddef.h>
#include <stdint.h>
#include <iostream>
#include <cassert>

#include "Chassis/r1000sc.h"
#include "Infra/context.h"

#include "Chassis/r1000_arch.hh"

#include "Diag/diagproc.h"

#include "Infra/cache_line.h"
#include "Iop/iop_sc_68k20.hh"
#include "Infra/vend.h"

static uint8_t fiu_pa025[512];
static uint8_t fiu_pa026[512];
static uint8_t fiu_pa027[512];
static uint8_t fiu_pa028[512];
static uint8_t fiu_pa060[512];
static uint8_t seq_pa040[512];
static uint8_t seq_pa041[512];
static uint8_t seq_pa042[512];
static uint8_t seq_pa043[512];
static uint8_t seq_pa044[512];
static uint8_t seq_pa045[512];
static uint8_t seq_pa046[512];
static uint8_t seq_pa047[512];
static uint8_t seq_pa048[512];
static uint8_t typ_pa068[512];
static uint8_t typ_pa059[512];
static uint8_t val_pa011[512];
static uint8_t ioc_pb011[32];
static uint8_t tv_pa010[512];

// -------------------- MEM --------------------

#define CMD_PMW	(1<<0xf)	// PHYSICAL_MEM_WRITE
#define CMD_PMR	(1<<0xe)	// PHYSICAL_MEM_READ
#define CMD_LMW	(1<<0xd)	// LOGICAL_MEM_WRITE
#define CMD_LMR	(1<<0xc)	// LOGICAL_MEM_READ
#define CMD_C01	(1<<0xb)	// COPY 0 TO 1
#define CMD_MTT	(1<<0xa)	// MEMORY_TO_TAGSTORE
#define CMD_C10	(1<<0x9)	// COPY 1 TO 0
#define CMD_SFF	(1<<0x8)	// SET HIT FLIP FLOPS
#define CMD_PTW	(1<<0x7)	// PHYSICAL TAG WRITE
#define CMD_PTR	(1<<0x6)	// PHYSICAL TAG READ
#define CMD_INI	(1<<0x5)	// INITIALIZE MRU
#define CMD_LTR	(1<<0x4)	// LOGICAL TAG READ
#define CMD_NMQ	(1<<0x3)	// NAME QUERY
#define CMD_LRQ	(1<<0x2)	// LRU QUERY
#define CMD_AVQ	(1<<0x1)	// AVAILABLE QUERY
#define CMD_IDL	(1<<0x0)	// IDLE
#define CMDS(x) ((state->mem_bcmd & (x)) != 0)

#define BSET_0	0x01
#define BSET_1	0x02
#define BSET_2	0x04
#define BSET_3	0x08
#define BSET_4	0x10
#define BSET_5	0x20
#define BSET_6	0x40
#define BSET_7	0x80

static unsigned
dolru(unsigned lru, unsigned before, unsigned cmd)
{
	unsigned then = (before >> 2) & 0xf;
	unsigned now = then;
	if (now == lru) {
		now = 7;
		if (cmd == 0xd)
			now |= 0x10;
	} else if (now > lru) {
		now -= 1;
	}
	if ((then & 0x8) || (now & 0x8))
		std::cerr <<"BADLRU " << std::hex << lru << " " << before << " " << then << " " << now << " " << cmd << "\n";
	return ((before & 0x43) | (now << 2));
}


// -------------------- SEQ --------------------

#define RND_PUSH		(1<<31)
#define RND_POP		(1<<30)
#define RND_CLEAR_ST		(1<<29)
#define RND_RESTRT0		(1<<28)
#define RND_RESTRT1		(1<<27)
#define RND_FLD_CHK		(1<<26)
#define RND_TOP_LD		(1<<25)
#define RND_HALT		(1<<24)

#define RND_CNTL_MUX		(1<<23)
#define RND_CHK_EXIT		(1<<22)
#define RND_RETRN_LD		(1<<21)
#define RND_M_PC_MUX		(1<<20)
#define RND_M_PC_MD0		(1<<19)
#define RND_M_PC_MD1		(1<<18)
#define RND_M_PC_LDH		(1<<17)
#define RND_ADR_SEL		(1<<16)

#define RND_TOS_VLB		(1<<15)
#define RND_RES_OFFS		(1<<14)
#define RND_RES_NAME		(1<<13)
#define RND_CUR_LEX		(1<<12)
#define RND_NAME_LD		(1<<11)
#define RND_SAVE_LD		(1<<10)
#define RND_PRED_LD		(1<< 9)
#define RND_L_ABRT		(1<< 8)

#define RND_LEX_COMM0		(1<< 7)
#define RND_LEX_COMM1		(1<< 6)
#define RND_LEX_COMM2		(1<< 5)
#define RND_CIB_PC_L		(1<< 4)
#define RND_INSTR_MX		(1<< 3)
#define RND_IBUFF_LD		(1<< 2)
#define RND_BR_MSK_L		(1<< 1)
#define RND_INSTR_LD		(1<< 0)
#define RNDX(x) ((state->seq_rndx & (x)) != 0)


// -------------------- TYP --------------------


#define TYP_A_LSB BUS64_LSB
#define TYP_B_LSB BUS64_LSB
#define TYP_A_BITS(n) (state->typ_a >> TYP_A_LSB(n))
#define TYP_B_BITS(n) (state->typ_b >> TYP_B_LSB(n))
#define TYP_A_BIT(n) (TYP_A_BITS(n) & 1)
#define TYP_B_BIT(n) (TYP_B_BITS(n) & 1)
#define TYP_A_LIT() (state->typ_a & 0x7f)
#define TYP_B_LIT() (state->typ_b & 0x7f)


// -------------------- IOC --------------------

	#define XIOP_VARIANT 1

struct r1000_arch_state {
	struct ctx ctx;
	unsigned pit;
	unsigned when;


// -------------------- MEM --------------------

	uint64_t *mem_ram;
	uint8_t *mem_rame;
	uint64_t *mem_bitt;
	unsigned mem_cl, mem_wd;
	uint64_t mem_tdreg, mem_tqreg;
	uint64_t mem_vdreg, mem_vqreg;

	unsigned mem_word;
	uint64_t mem_qreg;
	unsigned mem_hash;
	uint64_t mem_mar_space, mem_mar_name, mem_mar_page;
	bool mem_cstop;
	unsigned mem_hit_lru;
	bool mem_eabort, mem_labort;
	bool mem_p_mcyc2_next;
	unsigned mem_q4cmd;
	unsigned mem_q4cont;
	unsigned mem_hits;
	bool mem_cyo, mem_cyt;
	unsigned mem_cmd, mem_bcmd;
	unsigned mem_mar_set;


// -------------------- FIU --------------------

	unsigned fiu_oreg;
	uint64_t fiu_mdreg;
	uint64_t fiu_treg;
	uint64_t fiu_vreg;
	uint64_t fiu_refresh_reg;
	uint64_t fiu_marh;
	uint64_t fiu_ti_bus, fiu_vi_bus;
	unsigned fiu_lfreg;

	uint32_t fiu_srn, fiu_sro, fiu_ctopn, fiu_ctopo;
	unsigned fiu_nve, fiu_pdreg;
	unsigned fiu_moff;
	bool fiu_pdt;

	bool fiu_state0, fiu_state1, fiu_labort, fiu_e_abort_dly;
	uint8_t fiu_pcntl_d;
	uint8_t fiu_lcntl;
	uint8_t fiu_mcntl;
	bool fiu_scav_trap;
	bool fiu_cache_miss;
	bool fiu_csa_oor;
	bool fiu_page_xing;
	bool fiu_init_mru_d;
	bool fiu_drive_mru;
	bool fiu_memcnd;
	bool fiu_cndtru;
	bool fiu_incmplt_mcyc;
	bool fiu_mar_modified;
	bool fiu_write_last;
	bool fiu_phys_ref;
	bool fiu_phys_last;
	bool fiu_log_query;
	bool fiu_mctl_is_read;
	bool fiu_logrw;
	bool fiu_logrw_d;
	bool fiu_omf20;
	bool fiu_nmatch;
	bool fiu_in_range;
	unsigned fiu_setq;
	unsigned fiu_omq;
	unsigned fiu_prmt;
	bool fiu_dumon;
	bool fiu_memex;
	bool fiu_logrwn;
	bool fiu_page_crossing_next;
	bool fiu_miss;
	bool fiu_csaht;
	bool fiu_csa_oor_next;

	unsigned fiu_tcsa_sr;
	unsigned fiu_tcsa_inval_csa;
	unsigned fiu_tcsa_tf_pred;

	uint64_t *fiu_wcsram;
	uint64_t *fiu_typwcsram;
	uint64_t fiu_uir;
	uint64_t fiu_typuir;

	unsigned fiu_hit_offset;
	bool fiu_tmp_csa_oor_next;
	bool fiu_scav_trap_next;
	bool fiu_memcyc1;
	bool fiu_uev10_page_x;
	bool fiu_uev0_memex;
	unsigned fiu_mem_start;
	bool fiu_memstart;
	unsigned fiu_pa025d, fiu_pa026d, fiu_pa027d;

#define UIR_FIU_OL		((state->fiu_uir >> 40) & 0x7f)
#define UIR_FIU_LFL	((state->fiu_uir >> 32) & 0x7f)
#define UIR_FIU_LFRC	((state->fiu_uir >> 30) & 0x3)
#define UIR_FIU_OP		((state->fiu_uir >> 28) & 0x3)
#define UIR_FIU_SEL	((state->fiu_uir >> 26) & 0x3)
#define UIR_FIU_FSRC	((state->fiu_uir >> 25) & 1)
#define UIR_FIU_ORSR	((state->fiu_uir >> 24) & 1)
#define UIR_FIU_TIVI	((state->fiu_uir >> 20) & 0xf)
#define UIR_FIU_OCLK	((state->fiu_uir >> 19) & 1)
#define UIR_FIU_VCLK	((state->fiu_uir >> 18) & 1)
#define UIR_FIU_TCLK	((state->fiu_uir >> 17) & 1)
#define UIR_FIU_LDMDR	((state->fiu_uir >> 16) & 1)
#define UIR_FIU_MSTRT	((state->fiu_uir >> 10) & 0x1f)
#define UIR_FIU_RDSRC	((state->fiu_uir >> 9) & 1)
#define UIR_FIU_LSRC	((state->fiu_uir >> 1) & 1)
#define UIR_FIU_OSRC	((state->fiu_uir >> 0) & 1)


// -------------------- SEQ --------------------

	uint32_t *seq_top;
	uint32_t *seq_bot;
	uint32_t seq_cbot, seq_ctop;
	unsigned seq_emac;
	unsigned seq_curins;
	bool seq_topbot;

	uint64_t seq_macro_ins_typ, seq_macro_ins_val;
	unsigned seq_word;
	unsigned seq_macro_pc_offset;
	unsigned seq_curr_lex;
	unsigned seq_retrn_pc_ofs;
	unsigned seq_break_mask;

	uint64_t seq_tost, seq_vost, seq_cur_name;
	uint64_t seq_namram[1<<4];
	uint64_t seq_pcseg, seq_retseg;

	uint64_t seq_tosram[1<<4];
	uint64_t seq_tosof;
	uint32_t seq_savrg;
	uint32_t seq_pred;
	uint32_t seq_topcnt;

	uint16_t seq_ram[16];
	uint16_t seq_topu;
	uint16_t seq_adr;
	unsigned seq_fiu;
	unsigned seq_other;
	unsigned seq_late_u;
	unsigned seq_uev;

	uint8_t seq_bhreg;
	unsigned seq_rreg;
	unsigned seq_lreg;
	unsigned seq_treg;
	bool seq_hint_last;
	bool seq_hint_t_last;
	bool seq_last_late_cond;
	bool seq_uadr_mux, seq_preturn, seq_push_br, seq_push;
	uint64_t seq_typ_bus;
	uint64_t seq_val_bus;
	uint64_t seq_output_ob;
	uint64_t seq_name_bus;
	uint64_t seq_coff;
	unsigned seq_uadr_decode;
	unsigned seq_display;
	uint64_t seq_resolve_offset;
	bool seq_cload;
	bool seq_ibuf_fill;
	bool seq_uses_tos;
	bool seq_l_macro_hic;
	bool seq_m_pc_mb;
	unsigned seq_n_in_csa;
	unsigned seq_decode;
	unsigned seq_wanna_dispatch;
	bool seq_ibld;
	bool seq_field_number_error;
	bool seq_import_condition;
	bool seq_m_break_class;
	bool seq_latched_cond;
	bool seq_saved_latched;
	bool seq_stack_size_zero;
	unsigned seq_rq;
	bool seq_m_tos_invld;
	bool seq_tos_vld_cond;
	bool seq_foo7;
	bool seq_check_exit_ue;
	bool seq_carry_out;
	bool seq_bad_hint;
	bool seq_m_res_ref;
	bool seq_bad_hint_enable;
	bool seq_ferr;
	bool seq_late_macro_event;
	bool seq_sf_stop;
	bool seq_s_state_stop;
	bool seq_clock_stop_1;
	bool seq_clock_stop_5;
	unsigned seq_diag;
	unsigned seq_countdown;

	uint16_t seq_lex_valid;
	bool seq_lxval;
	unsigned seq_resolve_address;
	bool seq_m_ibuff_mt;
	bool seq_foo9;
	bool seq_q3cond;
	bool seq_stop;
	uint64_t *seq_wcsram;
	uint64_t seq_uir;

	unsigned seq_urand;
	unsigned seq_rndx;
	unsigned seq_br_type;
	unsigned seq_br_tim;
	bool seq_macro_event;
	unsigned seq_lmp;
	bool seq_early_macro_pending;
	bool seq_maybe_dispatch;
	bool seq_sign_extend;
	unsigned seq_intreads;
	bool seq_tmp_carry_out;
	bool uses_tos;
	unsigned seq_mem_start;

#define UIR_SEQ_BRN	((state->seq_uir >> (41-13)) & 0x3fff)
#define UIR_SEQ_LUIR	((state->seq_uir >> (41-15)) & 0x1)
#define UIR_SEQ_BRTYP	((state->seq_uir >> (41-19)) & 0xf)
#define UIR_SEQ_BRTIM	((state->seq_uir >> (41-21)) & 0x3)
#define UIR_SEQ_CSEL	((state->seq_uir >> (41-28)) & 0x7f)
#define UIR_SEQ_LAUIR	((state->seq_uir >> (41-30)) & 0x3)
#define UIR_SEQ_ENMIC	((state->seq_uir >> (41-31)) & 0x1)
#define UIR_SEQ_IRD	((state->seq_uir >> (41-34)) & 0x7)
#define UIR_SEQ_URAND	((state->seq_uir >> (41-41)) & 0x7f)


// -------------------- TYP --------------------

	uint64_t *typ_rfram;
	uint64_t typ_a, typ_b, c, typ_nalu, typ_alu;
	uint64_t typ_wdr;
	uint64_t typ_count;
	unsigned typ_csa_offset;
	unsigned typ_topreg;
	unsigned typ_botreg;
	bool typ_csa_hit;
	bool typ_csa_write;
	unsigned typ_aadr;
	unsigned typ_badr;
	unsigned typ_cadr;
	bool typ_cond;
	bool typ_almsb;
	bool typ_coh;
	bool typ_com;
	uint32_t typ_ofreg;
	bool typ_ppriv;
	bool typ_last_cond;
	bool typ_wen;
	bool typ_is_binary;
	bool typ_sub_else_add;
	bool typ_ovr_en;
	uint64_t *typ_wcsram;
	uint64_t typ_uir;
	unsigned typ_rand;
	unsigned typ_frm;

#define UIR_TYP_A		((state->typ_uir >> 41) & 0x3f)
#define UIR_TYP_B		((state->typ_uir >> 35) & 0x3f)
#define UIR_TYP_FRM	((state->typ_uir >> 30) & 0x1f)
#define UIR_TYP_RAND	((state->typ_uir >> 24) & 0xf)
#define UIR_TYP_C		((state->typ_uir >> 18) & 0x3f)
#define UIR_TYP_CLIT	(((state->typ_uir >> (46-16)) & 0x1f) | (((state->typ_uir >> (46-18) & 0x3)<<5)))
#define UIR_TYP_UPVC	((state->typ_uir >> 15) & 0x7)
#define UIR_TYP_SEL	((state->typ_uir >> 14) & 0x1)
#define UIR_TYP_AFNC	((state->typ_uir >> 9) & 0x1f)
#define UIR_TYP_CSRC	((state->typ_uir >> 8) & 0x1)
#define UIR_TYP_MCTL	((state->typ_uir >> 4) & 0xf)
#define UIR_TYP_CCTL	((state->typ_uir >> 1) & 0x7)


// -------------------- VAL --------------------

	uint64_t *val_rfram;
	uint64_t val_a, val_b, val_c;
	uint64_t val_wdr;
	uint64_t val_zerocnt;
	uint64_t val_malat, val_mblat, val_mprod, val_msrc;
	uint64_t val_nalu, val_alu;
	unsigned val_count;
	unsigned val_csa_offset;
	unsigned val_topreg;
	unsigned val_botreg;
	bool val_csa_hit;
	bool val_csa_write;
	unsigned val_cadr;
	bool val_amsb, val_bmsb, val_cmsb, val_mbit, val_last_cond;
	bool val_isbin, val_sub_else_add, val_ovren, val_carry_middle;
	bool val_coh;
	bool val_wen;
	bool val_cwe;
	uint64_t *val_wcsram;
	uint64_t val_uir;
	unsigned val_rand;
	bool val_thiscond;

#define UIR_VAL_A		((state->val_uir >> (39-5)) & 0x3f)
#define UIR_VAL_B		((state->val_uir >> (39-11)) & 0x3f)
#define UIR_VAL_FRM	((state->val_uir >> (39-16)) & 0x1f)
#define UIR_VAL_SEL	((state->val_uir >> (39-18)) & 0x3)
#define UIR_VAL_RAND	((state->val_uir >> (39-22)) & 0xf)
#define UIR_VAL_C		((state->val_uir >> (39-28)) & 0x3f)
#define UIR_VAL_MSRC	((state->val_uir >> (39-32)) & 0xf)
#define UIR_VAL_AFNC	((state->val_uir >> (39-37)) & 0x1f)
#define UIR_VAL_CSRC	((state->val_uir >> (39-38)) & 0x1)


// -------------------- IOC --------------------

	uint64_t ioc_dummy_typ, ioc_dummy_val;

	unsigned ioc_iack;
	struct ioc_sc_bus_xact *ioc_xact;
	unsigned ioc_fffff400;
	bool ioc_request_int_en;
	bool ioc_response_int_en;
	unsigned ioc_reqfifo[1024], ioc_reqwrp, ioc_reqrdp, ioc_reqreg;
	unsigned ioc_rspfifo[1024], ioc_rspwrp, ioc_rsprdp;
	bool ioc_cpu_running;
	uint8_t *ioc_ram;
	unsigned ioc_acnt;
	unsigned ioc_areg;
	unsigned ioc_rdata;
	unsigned ioc_rtc;

	unsigned ioc_prescaler;
	uint16_t ioc_delay, ioc_slice;
	bool ioc_slice_ev, ioc_delay_ev;
	bool ioc_sen, ioc_den, ioc_ten;
	bool ioc_dumen;
	bool ioc_csa_hit;
	uint16_t *ioc_tram;
	uint64_t *ioc_wcsram;
	uint64_t ioc_uir;
	bool ioc_is_tracing;

#define UIR_IOC_ULWDR	((state->ioc_uir >> 13) & 0x1)
#define UIR_IOC_RAND	((state->ioc_uir >>  8) & 0x1f)
#define UIR_IOC_AEN	((state->ioc_uir >>  6) & 0x3)
#define UIR_IOC_FEN	((state->ioc_uir >>  4) & 0x3)
#define UIR_IOC_TVBS	((state->ioc_uir >>  0) & 0xf)
};

r1000_arch :: r1000_arch(void)
{
	state = (struct r1000_arch_state *)
	    CTX_Get("r1000_arch", sizeof *state);
	should_i_trace("r1000_arch", &state->ctx.do_trace);



// -------------------- MEM --------------------

	state->mem_bcmd = 1 << state->mem_cmd;
	state->mem_bitt = (uint64_t*)CTX_GetRaw("MEM.bitt", sizeof(*state->mem_bitt) << 22);
			// Turbo 12 bit line, 3 bit set, 6 bit word, 1 bit T/V
	state->mem_ram = (uint64_t*)CTX_GetRaw("MEM.ram", sizeof(*state->mem_ram) << 15);
			// Turbo 12 bit line, 3 bit set
	state->mem_rame = (uint8_t*)CTX_GetRaw("MEM.rame", sizeof(*state->mem_rame) << 15);
			// Turbo 12 bit line, 3 bit set


// -------------------- FIU --------------------

	load_programmable("r1000_arch", fiu_pa025, sizeof fiu_pa025, "PA025-03");
	load_programmable("r1000_arch", fiu_pa026, sizeof fiu_pa026, "PA026-02");
	load_programmable("r1000_arch", fiu_pa027, sizeof fiu_pa027, "PA027-01");
	load_programmable("r1000_arch", fiu_pa028, sizeof fiu_pa028, "PA028-02");
	load_programmable("r1000_arch", fiu_pa060, sizeof fiu_pa060, "PA060");
	state->fiu_wcsram = (uint64_t*)CTX_GetRaw("FIU_WCS", sizeof(uint64_t) << 14);
	state->fiu_typwcsram = (uint64_t*)CTX_GetRaw("TYP_WCS", sizeof(uint64_t) << 14);


// -------------------- SEQ --------------------

	load_programmable("r1000_arch", seq_pa040, sizeof seq_pa040, "PA040-02");
	load_programmable("r1000_arch", seq_pa041, sizeof seq_pa041, "PA041-01");
	load_programmable("r1000_arch", seq_pa042, sizeof seq_pa041, "PA042-02");
	load_programmable("r1000_arch", seq_pa043, sizeof seq_pa043, "PA043-02");
	load_programmable("r1000_arch", seq_pa044, sizeof seq_pa044, "PA044-01");
	load_programmable("r1000_arch", seq_pa045, sizeof seq_pa045, "PA045-03");
	load_programmable("r1000_arch", seq_pa046, sizeof seq_pa046, "PA046-02");
	load_programmable("r1000_arch", seq_pa047, sizeof seq_pa047, "PA047-02");
	load_programmable("r1000_arch", seq_pa048, sizeof seq_pa048, "PA048-02");
	state->seq_wcsram = (uint64_t*)CTX_GetRaw("SEQ_WCS", sizeof(uint64_t) << UADR_WIDTH);
	state->seq_top = (uint32_t*)CTX_GetRaw("SEQ_TOP", sizeof(uint32_t) << 10);
	state->seq_bot = (uint32_t*)CTX_GetRaw("SEQ_BOT", sizeof(uint32_t) << 10);


// -------------------- TYP --------------------

	load_programmable("r1000_arch", tv_pa010, sizeof tv_pa010, "PA010");
	load_programmable("r1000_arch", typ_pa068, sizeof typ_pa068, "PA068");
	load_programmable("r1000_arch", typ_pa059, sizeof typ_pa059, "PA059-01");
	state->typ_wcsram = (uint64_t*)CTX_GetRaw("TYP_WCS", sizeof(uint64_t) << 14);
	state->typ_rfram = (uint64_t*)CTX_GetRaw("TYP_RF", sizeof(uint64_t) << 10);


// -------------------- VAL --------------------

	load_programmable("r1000_arch", val_pa011, sizeof val_pa011, "PA011");
	state->val_wcsram = (uint64_t*)CTX_GetRaw("VAL_WCS", sizeof(uint64_t) << 14);
	state->val_rfram = (uint64_t*)CTX_GetRaw("VAL_RF", sizeof(uint64_t) << 10);
	state->val_csa_hit = true;
	state->val_csa_write = true;


// -------------------- IOC --------------------

	load_programmable("r1000_arch", ioc_pb011, sizeof ioc_pb011, "PB011");
	state->ioc_wcsram = (uint64_t*)CTX_GetRaw("IOC_WCS", sizeof(uint64_t) << 14);
	state->ioc_tram = (uint16_t*)CTX_GetRaw("IOC_TRAM", sizeof(uint16_t) * 2049);

	struct ctx *c1 = CTX_Find("IOP.ram_space");
	assert(c1 != NULL);
	state->ioc_ram = (uint8_t*)(c1 + 1);
	state->ioc_is_tracing = false;
}

void
r1000_arch :: doit(void)
{
	state->ctx.activations++;

	mem_q4();
	fiu_q4();
	typ_q4();
	val_q4();
	ioc_q4();
	seq_q4();

	if (++state->pit == 256) {
		pit_clock();
		state->pit = 0;
	}
	update_state();

	mem_h1();
	typ_h1();
	val_h1();
	ioc_h1();
	seq_h1();

	fiu_q1();
	seq_q1();

	fiu_q2();
	typ_q2();
	val_q2();
	ioc_q2();
	seq_q2();

	seq_q3();
}


// -------------------- MEM --------------------

unsigned
r1000_arch ::
find_set(unsigned cmd)
{
	unsigned set2 = 0;
	if (state->mem_hits & (BSET_3|BSET_7)) {
		set2 = 3;
	} else if (state->mem_hits & (BSET_2|BSET_6)) {
		set2 = 2;
	} else if (state->mem_hits & (BSET_1|BSET_5)) {
		set2 = 1;
	} else if (state->mem_hits & (BSET_0|BSET_4)) {
		set2 = 0;
	} else if (cmd == 0xe && ((state->mem_mar_set & ~4) == 2)) {
		set2 = 2;
	} else {
		set2 = 3;
	}
	if (state->mem_hits & (BSET_4|BSET_5|BSET_6|BSET_7)) {
		set2 |= 4;
	}
	return (set2);
}

bool
r1000_arch ::
is_hit(unsigned adr, unsigned eadr, unsigned set)
{
	if (state->mem_labort)
		return false;

	if CMDS(CMD_IDL)
		return (true);

	unsigned tag = state->mem_rame[eadr];

	unsigned page_state = tag & 3;
	// R1000_Micro_Arch_Mem.pdf p19:
	//    00: Loading, 01: Read-only, 10: Read-Write, 11: Invalid

	uint64_t data = state->mem_ram[adr];
	uint64_t ta = data >> 19;
	uint64_t ts = data & 0x7;

	bool name = (state->mem_mar_name == (ta >> 13));
	bool offset = (state->mem_mar_page == (ta & 0x1fff)) && (state->mem_mar_space == ts);
	if CMDS(CMD_AVQ)
		return (page_state == 0);
	if CMDS(CMD_LTR)
		return (name && offset && page_state != 0);
	if CMDS(CMD_LRQ)
		return (((tag >> 2) & 0xf) == 0);
	if CMDS(CMD_NMQ)
		return (name && (page_state != 0));
	if CMDS(CMD_LMR)
		return (name && offset && (page_state == 1 || page_state == 2));
	if CMDS(CMD_LMW)
		return (name && offset && page_state == 1);
	return (state->mem_mar_set == set);
}

void
r1000_arch ::
load_mar(void)
{
	uint64_t a;
	uint32_t s;

	s = mp_spc_bus;
	a = mp_adr_bus;
	state->mem_mar_space = s;
	state->mem_mar_name = (a>>32) & 0xffffffffULL;
	state->mem_mar_page = (a>>19) & 0x1fff;
	state->mem_mar_set = (a>>BUS64_LSB(27)) & 0xf;

	state->mem_word = (a >> 7) & 0x3f;
	state->mem_hash = 0;
	state->mem_hash ^= cache_line_tbl_h[(a >> 42) & 0x3ff];
	state->mem_hash ^= cache_line_tbl_l[(a >> 13) & 0xfff];
	state->mem_hash ^= cache_line_tbl_s[state->mem_mar_space & 0x7];
}

void
r1000_arch ::
mem_h1(void)
{
	bool labort = !(mp_mem_abort_l && mp_mem_abort_el);
	bool p_early_abort = state->mem_eabort;
	bool p_mcyc2_next_hd = state->mem_p_mcyc2_next;
	if (p_early_abort && p_mcyc2_next_hd) {
		state->mem_cmd = 0;
	} else {
		state->mem_cmd = state->mem_q4cmd ^ 0xf;
	}
	state->mem_bcmd = 1 << state->mem_cmd;
	state->mem_p_mcyc2_next =
		!(
			((state->mem_q4cmd != 0xf) && (!p_early_abort) && p_mcyc2_next_hd) ||
			((!state->mem_q4cont) && (!p_early_abort) && (!p_mcyc2_next_hd))
		);
	state->mem_cyo = !((state->mem_q4cmd != 0xf) && (!p_early_abort) && p_mcyc2_next_hd);
	state->mem_cyt = p_mcyc2_next_hd;

	if (state->mem_cyo) {
		if        (state->mem_hits & BSET_4) { mp_mem_set = 0;
		} else if (state->mem_hits & BSET_5) { mp_mem_set = 1;
		} else if (state->mem_hits & BSET_6) { mp_mem_set = 2;
		} else if (state->mem_hits & BSET_7) { mp_mem_set = 3;
		} else if (state->mem_hits & BSET_0) { mp_mem_set = 0;
		} else if (state->mem_hits & BSET_1) { mp_mem_set = 1;
		} else if (state->mem_hits & BSET_2) { mp_mem_set = 2;
		} else                           { mp_mem_set = 3;
		}

		mp_mem_hit = 0xf;
		if (state->mem_hits & (BSET_0|BSET_1|BSET_2|BSET_3))
			mp_mem_hit &= ~1;
		if (state->mem_hits & (BSET_4|BSET_5|BSET_6|BSET_7))
			mp_mem_hit &= ~8;
		if (state->mem_hits) {
			unsigned tadr = state->mem_hash << 3;
			     if (state->mem_hits & BSET_0)	state->mem_hit_lru = state->mem_rame[tadr | 0];
			else if (state->mem_hits & BSET_1)	state->mem_hit_lru = state->mem_rame[tadr | 1];
			else if (state->mem_hits & BSET_2)	state->mem_hit_lru = state->mem_rame[tadr | 2];
			else if (state->mem_hits & BSET_3)	state->mem_hit_lru = state->mem_rame[tadr | 3];
			else if (state->mem_hits & BSET_4)	state->mem_hit_lru = state->mem_rame[tadr | 4];
			else if (state->mem_hits & BSET_5)	state->mem_hit_lru = state->mem_rame[tadr | 5];
			else if (state->mem_hits & BSET_6)	state->mem_hit_lru = state->mem_rame[tadr | 6];
			else if (state->mem_hits & BSET_7)	state->mem_hit_lru = state->mem_rame[tadr | 7];
			state->mem_hit_lru >>= 2;
			state->mem_hit_lru &= 0xf;
		} else {
			state->mem_hit_lru = 0xf;
		}
	}
	if (!state->mem_cyt) {
		if (CMDS(CMD_PTR)) {
			unsigned padr = (state->mem_hash << 3) | (state->mem_mar_set & 0x7);
			state->mem_qreg = state->mem_ram[padr] & ~(0x7fULL << 6);
			state->mem_qreg |= (state->mem_rame[padr] & 0x7f) << 6;
		}
	}

	if (!state->mem_cyt) {
		if (CMDS(CMD_LMR|CMD_PMR) && !labort) {
			unsigned set = find_set(state->mem_cmd);
			uint32_t radr =	(set << 18) | (state->mem_cl << 6) | state->mem_wd;
			assert(radr < (1 << 21));
			state->mem_tqreg = state->mem_bitt[radr+radr];
			state->mem_vqreg = state->mem_bitt[radr+radr+1];
		}
	}
	
	if (!state->mem_cyt) {
		bool ihit = mp_mem_hit == 0xf;
		if (CMDS(CMD_LMW|CMD_PMW) && !ihit && !state->mem_labort) {
			unsigned set = find_set(state->mem_cmd);
			uint32_t radr = (set << 18) | (state->mem_cl << 6) | state->mem_wd;
			assert(radr < (1 << 21));
			state->mem_bitt[radr+radr] = state->mem_tdreg;
			state->mem_bitt[radr+radr+1] = state->mem_vdreg;
		}

		if (CMDS(CMD_PTW)) {
			bool my_board = false;
			bool which_board = state->mem_mar_set >> 3;
			if (which_board == my_board) {
				unsigned padr = (state->mem_hash << 3) | (state->mem_mar_set & 0x7);
				state->mem_ram[padr] = state->mem_vdreg & ~(0x7fULL << 6);
				state->mem_rame[padr] = (state->mem_vdreg >> 6) & 0x7f;
			}
		} else if (!state->mem_labort && CMDS(CMD_LRQ|CMD_LMW|CMD_LMR)) {
			unsigned padr = state->mem_hash << 3;
			for (unsigned u = 0; u < 8; u++)
				state->mem_rame[padr + u] = dolru(state->mem_hit_lru, state->mem_rame[padr + u], state->mem_cmd);
		}
	}

	bool not_me = mp_mem_hit == 0xf;
	
	if (!mp_memv_oe && mp_memtv_oe) {
		if (not_me) {
			mp_val_bus = ~0ULL;
		} else {
			mp_val_bus = state->mem_qreg;
		}
	} else if (!mp_memtv_oe) {
		if (not_me) {
			mp_typ_bus = ~0ULL;
			mp_val_bus = ~0ULL;
		} else {
			mp_typ_bus = state->mem_tqreg;
			mp_val_bus = state->mem_vqreg;
		}
	}
}

void
r1000_arch ::
mem_q4(void)
{
	bool labort = !(mp_mem_abort_l && mp_mem_abort_el);

	state->mem_cl = state->mem_hash;
	state->mem_wd = state->mem_word;

	state->mem_cstop = mp_sync_freeze == 0;

	if (!(mp_load_wdr || !(mp_clock_stop_6 && mp_clock_stop_7))) {
		state->mem_tdreg = mp_typ_bus;
		state->mem_vdreg = mp_val_bus;
	}
	bool loadmar = !((mp_mar_cntl >= 4) && mp_clock_stop_7);
	if (!loadmar && state->mem_cstop) {
		load_mar();
	}

	if (!state->mem_cyo) {
		state->mem_hits = 0;
		unsigned badr = state->mem_hash << 3;
		if (is_hit(badr | 0, badr | 0, 0)) state->mem_hits |= BSET_0;
		if (is_hit(badr | 1, badr | 1, 1)) state->mem_hits |= BSET_1;
		if (is_hit(badr | 2, badr | 2, 2)) state->mem_hits |= BSET_2;
		if (is_hit(badr | 3, badr | 3, 3)) state->mem_hits |= BSET_3;
		if (is_hit(badr | 4, badr | 4, 4)) state->mem_hits |= BSET_4;
		if (is_hit(badr | 5, badr | 5, 5)) state->mem_hits |= BSET_5;
		if (is_hit(badr | 6, badr | 6, 6)) state->mem_hits |= BSET_6;
		if (is_hit(badr | 7, badr | 7, 7)) state->mem_hits |= BSET_7;
	}
	state->mem_q4cmd = mp_mem_ctl;
	state->mem_q4cont = mp_mem_continue;
	state->mem_labort = labort;
	state->mem_eabort = !(mp_mem_abort_e && mp_mem_abort_el);
}


// -------------------- FIU --------------------

uint64_t
r1000_arch ::
read_fiu_bus(unsigned line)
{
	return (~mp_fiu_bus);
}

bool
r1000_arch ::
fiu_conditions()
{

	switch(mp_cond_sel) {
	case 0x60: mp_condx3 = !state->fiu_memex; 		return(mp_condx3);
	case 0x61: mp_condx3 = !state->fiu_phys_last; 		return(mp_condx3);
	case 0x62: mp_condx3 = !state->fiu_write_last; 		return(mp_condx3);
	case 0x63: mp_condx3 = !mp_csa_hit; 		return(mp_condx3);
	case 0x64: mp_condx3 = !((state->fiu_oreg >> 6) & 1); 	return(mp_condx3);
	case 0x65: // Cross word shift
		mp_condx3 = (state->fiu_oreg + (state->fiu_lfreg & 0x3f) + (state->fiu_lfreg & 0x80)) <= 255;
		return(mp_condx3);
	case 0x66: mp_condx3 = (state->fiu_moff & 0x3f) > 0x30; 	return(mp_condx3);
	case 0x67: mp_condx3 = !(mp_refresh_count != 0xffff); 		return(mp_condx3);
	case 0x68: mp_condx2 = !state->fiu_csa_oor_next;		return(mp_condx2);
	case 0x69: mp_condx2 = !false; 			return(mp_condx2); // SCAV_HIT
	case 0x6a: mp_condx2 = !state->fiu_page_xing; 		return(mp_condx2);
	case 0x6b: mp_condx2 = !state->fiu_miss; 		return(mp_condx2);
	case 0x6c: mp_condx2 = !state->fiu_incmplt_mcyc; 	return(mp_condx2);
	case 0x6d: mp_condx2 = !state->fiu_mar_modified; 	return(mp_condx2);
	case 0x6e: mp_condx2 = !state->fiu_incmplt_mcyc; 	return(mp_condx2);
	case 0x6f: mp_condx2 = (state->fiu_moff & 0x3f) != 0; 	return(mp_condx2);
	};
	return (false);
}

uint64_t
r1000_arch ::
frame(void)
{
	uint64_t u = 0;

	uint64_t line = 0;
	line ^= cache_line_tbl_h[(state->fiu_srn >> 10) & 0x3ff];
	line ^= cache_line_tbl_l[(state->fiu_moff >> (13 - 7)) & 0xfff];
	line ^= cache_line_tbl_s[(state->fiu_sro >> 4) & 0x7];

	u |= (uint64_t)mp_mem_cond_pol << BUS64_LSB(9);
	u |= (uint64_t)mp_mem_cond << BUS64_LSB(10);
	u |= line << BUS64_LSB(23);
	u |= (uint64_t)state->fiu_setq << BUS64_LSB(25);
	u |= (uint64_t)mp_mem_set << BUS64_LSB(27);
	u |= (uint64_t)((state->fiu_omq >> 2) & 0x3) << BUS64_LSB(29);
	u |= 0x3ULL << BUS64_LSB(31);
	u |= (uint64_t)(state->fiu_uev10_page_x) << BUS64_LSB(32);
	u |= (uint64_t)((state->fiu_prmt >> 1) & 1) << BUS64_LSB(33);
	u |= (uint64_t)(mp_refresh_count != 0xffff) << BUS64_LSB(34);
	u |= (uint64_t)(state->fiu_uev0_memex) << BUS64_LSB(35);
	u |= ((line >> 0) & 1) << BUS64_LSB(48);
	u |= ((line >> 1) & 1) << BUS64_LSB(50);
	u |= (uint64_t)state->fiu_nmatch << BUS64_LSB(56);
	u |= (uint64_t)state->fiu_in_range << BUS64_LSB(57);
	u |= (uint64_t)state->fiu_csa_oor_next << BUS64_LSB(58);
	u |= (uint64_t)mp_csa_hit << BUS64_LSB(59);
	u |= (uint64_t)state->fiu_hit_offset;
	return (u);
}

void
r1000_arch ::
do_tivi(void)
{

	unsigned tivi = UIR_FIU_TIVI;

	uint64_t vi;
	switch (tivi) {
	case 0x00: case 0x04: case 0x08:
		vi = state->fiu_vreg;
		break;
	case 0x01: case 0x05: case 0x09:
		vi = ~mp_val_bus;
		break;
	case 0x02: case 0x06: case 0x0a:
		vi = read_fiu_bus(tivi);
		break;
	case 0x03: case 0x07: case 0x0b:
		vi = frame() ^ ~0ULL;
		break;
	default:
		vi = (uint64_t)state->fiu_srn << 32;
		vi |= state->fiu_sro & 0xffffff80;
		vi |= state->fiu_oreg;
		vi = ~vi;
		break;
	}
	uint64_t ti;
	switch (tivi) {
	case 0x00: case 0x01: case 0x02: case 0x03:
		ti = state->fiu_treg;
		break;
	case 0x04: case 0x05: case 0x06: case 0x07:
		ti = read_fiu_bus(tivi);
		break;
	case 0x08: case 0x09: case 0x0a: case 0x0b:
		ti = ~mp_typ_bus;
		break;
	default:
		uint64_t tmp;
		tmp = (state->fiu_sro >> 4) & 0x7;
		state->fiu_marh &= ~0x07;
		state->fiu_marh |= tmp;
		state->fiu_marh &= ~(0x1efULL << 23ULL);
		state->fiu_marh |= (uint64_t)(!state->fiu_incmplt_mcyc) << 23;
		state->fiu_marh |= (uint64_t)(!state->fiu_mar_modified) << 24;
		state->fiu_marh |= (uint64_t)(!state->fiu_write_last) << 25;
		state->fiu_marh |= (uint64_t)(!state->fiu_phys_last) << 26;
		state->fiu_marh |= (uint64_t)(!state->fiu_cache_miss) << 28;
		state->fiu_marh |= (uint64_t)(!state->fiu_page_xing) << 29;
		state->fiu_marh |= (uint64_t)(!state->fiu_csa_oor) << 30;
		state->fiu_marh |= (uint64_t)(!state->fiu_scav_trap) << 31;
		ti = ~state->fiu_marh;
		break;
	}
	state->fiu_ti_bus = ti;
	state->fiu_vi_bus = vi;
}

void
r1000_arch ::
rotator(bool sclk)
{
	uint64_t rot = 0;
	uint64_t vmsk = 0, tmsk = 0;
	bool sgnbit = 0;
	uint64_t ft, tir, vir;
	unsigned s, fs, sgn;
	bool zero_length;

	unsigned lfl = UIR_FIU_LFL;

	bool fill_mode = false;
	if (UIR_FIU_FSRC) {				// UCODE
		fill_mode = lfl >> 6;
	} else {
		fill_mode = (state->fiu_lfreg >> 6) & 1;
	}

	unsigned lenone;
	if (UIR_FIU_LSRC) {				// UCODE
		lenone = lfl & 0x3f;
	} else {
		lenone = state->fiu_lfreg & 0x3f;
	}

	zero_length = !(fill_mode & (lenone == 0x3f));

	unsigned offset;
	if (UIR_FIU_OSRC) {				// UCODE
		offset = UIR_FIU_OL;
	} else {
		offset = state->fiu_oreg;
	}


	unsigned op, sbit, ebit;
	op = UIR_FIU_OP;				// UCODE
	switch (op) {
	case 0:
		sbit = (lenone ^ 0x3f) | (1<<6);
		ebit = 0x7f;
		break;
	case 1:
		sbit = 0;
		ebit = (lenone & 0x3f) + (offset & 0x7f);
		break;
	case 2:
		sbit = offset;
		ebit = 0x7f;
		break;
	case 3:
		sbit = offset;
		ebit = (lenone & 0x3f) + (offset & 0x7f);
		break;
	}
	sbit &= 0x7f;
	ebit &= 0x7f;

	uint64_t msk6;
	if (op != 0) {
		msk6 = ~0ULL;
		if (((offset + lenone) & 3) != 3) {
			msk6 >>= 4;
		}
	} else {
		unsigned sx = (offset + (lenone & 3)) & ~0x3;
		if (sx == 0 || sx == 0x80) {
			msk6 = 0;
		} else if (sx < 0x40) {
			msk6 = ~0ULL << (64 - sx);
		} else {
			msk6 = ~0ULL >> (sx - 64);
		}
	}

	// The actual rotation
	if (op == 0) {
		s = (lenone ^ 0x3f) + 0xc0 - offset;
	} else {
		s = lenone + offset + 1;
	}		
	s &= 0x3f;

	fs = s & 3;
	if (fs == 0) {
		tir = state->fiu_ti_bus;
		vir = state->fiu_vi_bus;
	} else {
		tir = state->fiu_ti_bus >> fs;
		tir |= state->fiu_vi_bus << (64 - fs);
		vir = state->fiu_vi_bus >> fs;
		vir |= state->fiu_ti_bus << (64 - fs);
	}

	ft = msk6 & vir;
	ft |= (~msk6) & tir;

	if (fill_mode) {
		sgnbit = true;
	} else {
		sgn = offset & 0x3c;
		if ((offset & 3) + (lenone & 3) > 3)
			sgn += 4;
		sgn |= (lenone & 3) ^ 3;

		sgnbit = (ft >> (63 - sgn)) & 1;
	}

	{
		uint64_t yl = 0, yh = 0;
		fs = s & ~3;
		yl = ft >> fs;
		yh = ft << (64 - fs);
		rot = yh | yl;
	}

	if (zero_length) {
		if (ebit == sbit) {
			if (ebit < 64) {
				tmsk = 1ULL << (63 - ebit);
				vmsk = 0;
			} else {
				tmsk = 0;
				vmsk = 1ULL << (127 - ebit);
			} 
		} else {
			uint64_t inv = 0;
			unsigned sb = sbit, eb = ebit;
			if (eb < sb) {
				sb = ebit + 1;
				eb = sbit - 1;
				inv = ~(uint64_t)0;
			}
			if (sb < 64)
				tmsk = (~(uint64_t)0) >> sb;
			if (eb < 63)
				tmsk ^= (~(uint64_t)0) >> (eb + 1);
			if (eb > 63)
				vmsk = (~(uint64_t)0) << (127 - eb);
			if (sb > 64)
				vmsk ^= (~(uint64_t)0) << (128 - sb);
			tmsk ^= inv;
			vmsk ^= inv;
		}
	}

	unsigned sel = UIR_FIU_SEL;

	uint64_t tii = 0;
	switch(sel) {
	case 0:
	case 1:
		if (sgnbit)
			tii = ~0ULL;
		break;
	case 2:
		tii = state->fiu_vi_bus;
		break;
	case 3:
		tii = read_fiu_bus(0x20);
		break;
	}

	uint64_t rdq;
	if (UIR_FIU_RDSRC) {				// UCODE
		rdq = state->fiu_mdreg;
	} else {
		rdq = rot;
	}

	uint64_t vout = 0;
	vout = rdq & vmsk;
	vout |= tii & ~vmsk;

	if (mp_fiu_oe == 0x1) {
		mp_fiu_bus = ~vout;
	}

	if (sclk && UIR_FIU_LDMDR) {			// (UCODE)
		state->fiu_mdreg = rot;
	}

	if (sclk && !UIR_FIU_TCLK) {			// Q4~^
		state->fiu_treg = rdq & tmsk;
		state->fiu_treg |= state->fiu_ti_bus & ~tmsk;
	}

	if (sclk && !UIR_FIU_VCLK) {			// Q4~^
		state->fiu_vreg = vout;
	}


}

void
r1000_arch ::
tcsa(bool clock)
{
	bool invalidate_csa = !(mp_csa_hit && !state->fiu_tcsa_tf_pred);
	unsigned hit_offs = state->fiu_hit_offset;

	unsigned adr;
	if (state->fiu_tcsa_tf_pred) {
		adr = state->fiu_tcsa_sr;
		adr |= 0x100;
	} else {
		adr = hit_offs;
	}
	adr ^= 0xf;
	unsigned csacntl = mp_csa_cntl;
	adr |= csacntl << 4;

	if (state->fiu_tcsa_inval_csa)
		adr |= (1<<7);

	unsigned q = fiu_pa060[adr];
	bool load_ctl_top = (q >> 3) & 0x1;
	bool load_top_bot = (q >> 2) & 0x1;
	bool sel_constant = (q >> 1) & 0x1;
	bool minus_one = (q >> 0) & 0x1;

	mp_load_top = !(load_top_bot && ((csacntl >> 1) & 1));
	mp_load_bot = !(load_top_bot && ((csacntl >> 2) & 1));
	mp_pop_down = load_ctl_top && state->fiu_tcsa_tf_pred;

	if (!invalidate_csa) {
		mp_csa_offs = 0xf;
	} else if (!sel_constant && !minus_one) {
		mp_csa_offs = 0x1;
	} else if (!sel_constant && minus_one) {
		mp_csa_offs = 0xf;
	} else {
		mp_csa_offs = hit_offs;
	}

	mp_csa_nve = q >> 4;

	if (clock) {
		state->fiu_tcsa_sr = q >> 4;
		state->fiu_tcsa_inval_csa = invalidate_csa;
		unsigned csacntl0 = (state->fiu_typwcsram[mp_nua_bus] >> 1) & 7;
		unsigned csacntl1 = (state->fiu_typuir >> 1) & 6;
		state->fiu_tcsa_tf_pred = !((csacntl0 == 7) && (csacntl1 == 0));
	}

}

void
r1000_arch ::
fiu_q1(void)
{
	bool sclk = false;
	bool carry, name_match;

	unsigned pa028a = mp_mar_cntl << 5;
	pa028a |= state->fiu_incmplt_mcyc << 4;
	pa028a |= state->fiu_e_abort_dly << 3;
	pa028a |= state->fiu_state1 << 2;
	pa028a |= state->fiu_mctl_is_read << 1;
	pa028a |= state->fiu_dumon;
	state->fiu_prmt = fiu_pa028[pa028a];
	state->fiu_prmt ^= 0x02;
	state->fiu_prmt &= 0x7b;

	unsigned mar_cntl = mp_mar_cntl;
	bool rmarp = (mar_cntl & 0xe) == 0x4;
	state->fiu_mem_start = UIR_FIU_MSTRT ^ 0x1e;

	do_tivi();
	if (mp_fiu_oe == 0x1) {
		rotator(sclk);
	}
	unsigned dif;

	if (state->fiu_pdt) {
		carry = state->fiu_ctopo <= state->fiu_pdreg;
		dif = ~0xfffff + state->fiu_pdreg - state->fiu_ctopo;
	} else {
		carry = state->fiu_moff <= state->fiu_ctopo;
		dif = ~0xfffff + state->fiu_ctopo - state->fiu_moff;
	}
	dif &= 0xfffff;

	name_match = 
		    (state->fiu_ctopn != state->fiu_srn) ||
		    ((state->fiu_sro & 0xf8000070 ) != 0x10);

	state->fiu_in_range = (!state->fiu_pdt && name_match) || (dif & 0xffff0);

	state->fiu_hit_offset = (0xf + state->fiu_nve - (dif & 0xf)) & 0xf;

	mp_csa_hit = (bool)!(carry && !(state->fiu_in_range || ((dif & 0xf) >= state->fiu_nve)));

	unsigned pa025a = 0;
	pa025a |= state->fiu_mem_start;
	pa025a |= state->fiu_state0 << 8;
	pa025a |= state->fiu_state1 << 7;
	pa025a |= state->fiu_labort << 6;
	pa025a |= state->fiu_e_abort_dly << 5;
	state->fiu_pa025d = fiu_pa025[pa025a];
	state->fiu_memcyc1 = (state->fiu_pa025d >> 1) & 1;
	state->fiu_memstart = (state->fiu_pa025d >> 0) & 1;

	if (state->fiu_memstart) {
		state->fiu_mcntl = state->fiu_lcntl;
	} else {
		state->fiu_mcntl = state->fiu_pcntl_d;
	}
	state->fiu_phys_ref = !(state->fiu_mcntl & 0x6);
	state->fiu_logrwn = !(state->fiu_logrw && state->fiu_memcyc1);
	state->fiu_logrw = !(state->fiu_phys_ref || ((state->fiu_mcntl >> 3) & 1));

	state->fiu_scav_trap_next = state->fiu_scav_trap;
	if (mp_cond_sel == 0x69) {		// SCAVENGER_HIT
		state->fiu_scav_trap_next = false;
	} else if (rmarp) {
		state->fiu_scav_trap_next = (state->fiu_ti_bus >> BUS64_LSB(32)) & 1;
	} else if (state->fiu_log_query) {
		state->fiu_scav_trap_next = false;
	}


	state->fiu_tmp_csa_oor_next = state->fiu_csa_oor;
	if (mp_cond_sel == 0x68) {		// CSA_OUT_OF_RANGE
		state->fiu_tmp_csa_oor_next = false;
	} else if (rmarp) {
		state->fiu_tmp_csa_oor_next = (state->fiu_ti_bus >> BUS64_LSB(33)) & 1;
	} else if (state->fiu_log_query) {
		state->fiu_tmp_csa_oor_next = state->fiu_csa_oor_next;
	}

	bool pgmod = (state->fiu_omq >> 1) & 1;
	unsigned board_hit = mp_mem_hit;
	unsigned pa027a = 0;
	pa027a |= board_hit << 5;
	pa027a |= state->fiu_init_mru_d << 4;
	pa027a |= (state->fiu_omq & 0xc);
	pa027a |= 1 << 1;
	pa027a |= pgmod << 0;
	state->fiu_pa027d = fiu_pa027[pa027a];
	state->fiu_setq = (state->fiu_pa027d >> 3) & 3;

	bool mnor0b = state->fiu_drive_mru || ((state->fiu_pa027d & 3) == 0);
	bool mnan2a = !(mnor0b && state->fiu_logrw_d);
	state->fiu_miss = !(
		((board_hit != 0xf) && mnan2a) ||
		(state->fiu_logrw_d && state->fiu_csaht)
	);
	if (mp_refresh_count == 0xffff) {
		mp_macro_event |= 0x40;
	} else {
		mp_macro_event &= ~0x40;
	}
	//if (mp_cond_sel != 0x6b) {
	//	fiu_conditions();
	//}
	if ((!mp_fiut_oe || !mp_fiuv_oe)) {
		do_tivi();
		if (!mp_fiut_oe) {
			mp_typ_bus = ~state->fiu_ti_bus;
		}
		if (!mp_fiuv_oe) {
			mp_val_bus = ~state->fiu_vi_bus;
		}
	}
}

void
r1000_arch ::
fiu_q2(void)
{
	unsigned pa028a = mp_mar_cntl << 5;
	pa028a |= state->fiu_incmplt_mcyc << 4;
	pa028a |= state->fiu_e_abort_dly << 3;
	pa028a |= state->fiu_state1 << 2;
	pa028a |= state->fiu_mctl_is_read << 1;
	pa028a |= state->fiu_dumon;
	state->fiu_prmt = fiu_pa028[pa028a];
	state->fiu_prmt ^= 0x02;
	state->fiu_prmt &= 0x7b;

	do_tivi();
	unsigned pa025a = 0;
	pa025a |= state->fiu_mem_start;
	pa025a |= state->fiu_state0 << 8;
	pa025a |= state->fiu_state1 << 7;
	pa025a |= state->fiu_labort << 6;
	pa025a |= state->fiu_e_abort_dly << 5;
	state->fiu_pa025d = fiu_pa025[pa025a];
	state->fiu_memcyc1 = (state->fiu_pa025d >> 1) & 1;
	state->fiu_memstart = (state->fiu_pa025d >> 0) & 1;

	if (state->fiu_memstart) {
		state->fiu_mcntl = state->fiu_lcntl;
	} else {
		state->fiu_mcntl = state->fiu_pcntl_d;
	}
	state->fiu_phys_ref = !(state->fiu_mcntl & 0x6);
	state->fiu_logrwn = !(state->fiu_logrw && state->fiu_memcyc1);
	state->fiu_logrw = !(state->fiu_phys_ref || ((state->fiu_mcntl >> 3) & 1));

	unsigned mar_cntl = mp_mar_cntl;
	bool rmarp = (mar_cntl & 0xe) == 0x4;

	state->fiu_scav_trap_next = state->fiu_scav_trap;
	if (mp_cond_sel == 0x69) {		// SCAVENGER_HIT
		state->fiu_scav_trap_next = false;
	} else if (rmarp) {
		state->fiu_scav_trap_next = (state->fiu_ti_bus >> BUS64_LSB(32)) & 1;
	} else if (state->fiu_log_query) {
		state->fiu_scav_trap_next = false;
	}


	state->fiu_tmp_csa_oor_next = state->fiu_csa_oor;
	if (mp_cond_sel == 0x68) {		// CSA_OUT_OF_RANGE
		state->fiu_tmp_csa_oor_next = false;
	} else if (rmarp) {
		state->fiu_tmp_csa_oor_next = (state->fiu_ti_bus >> BUS64_LSB(33)) & 1;
	} else if (state->fiu_log_query) {
		state->fiu_tmp_csa_oor_next = state->fiu_csa_oor_next;
	}

	unsigned pa026a = state->fiu_mem_start;
	if (state->fiu_omq & 0x02)	// INIT_MRU_D
		pa026a |= 0x20;
	if (state->fiu_phys_last)
		pa026a |= 0x40;
	if (state->fiu_write_last)
		pa026a |= 0x80;
	state->fiu_pa026d = fiu_pa026[pa026a];
	// INIT_MRU, ACK_REFRESH, START_IF_INCM, START_TAG_RD, PCNTL0-3

	if (state->fiu_log_query) {
		// PIN_MISS instead of cache_miss_next looks suspicious
		// but confirmed on both /200 and /400 FIU boards.
		// 20230910/phk
		state->fiu_memex = !(!state->fiu_miss && !state->fiu_tmp_csa_oor_next && !state->fiu_scav_trap_next);
	} else {
		state->fiu_memex = !(!state->fiu_cache_miss && !state->fiu_csa_oor && !state->fiu_scav_trap);
	}
	mp_restore_rdr = (state->fiu_prmt >> 1) & 1;
	bool sel = !((!mp_state_clk_stop && state->fiu_memcyc1) || (mp_state_clk_en && !state->fiu_memcyc1));
	if (sel) {
		mp_dummy_next = !((state->fiu_prmt >> 0) & 1);
	} else {
		mp_dummy_next = !state->fiu_dumon;
	}
			
	mp_csa_wr = !(mp_mem_abort_l && mp_mem_abort_el && !(state->fiu_logrwn || (state->fiu_mcntl & 1)));
	if (mp_adr_oe & 0x1) {
		bool inc_mar = (state->fiu_prmt >> 3) & 1;
		unsigned inco = state->fiu_moff & 0x1f;
		if (inc_mar && inco != 0x1f)
			inco += 1;

		mp_adr_bus = (uint64_t)state->fiu_srn << 32;
		mp_adr_bus |= state->fiu_sro & 0xfffff000;
		mp_adr_bus |= (inco & 0x1f) << 7;
		mp_adr_bus |= state->fiu_oreg;
		mp_spc_bus = (state->fiu_sro >> 4) & 7;
	}

	state->fiu_lcntl = state->fiu_mcntl;
	state->fiu_drive_mru = state->fiu_init_mru_d;
	state->fiu_memcnd = (state->fiu_pa025d >> 4) & 1;	// CM_CTL0
	state->fiu_cndtru = (state->fiu_pa025d >> 3) & 1;	// CM_CTL1
	mp_mem_cond= !(state->fiu_memcnd);
	mp_mem_cond_pol = !(state->fiu_cndtru);
			
	if (state->fiu_memcyc1) {
		mp_mem_ctl= state->fiu_lcntl;
	} else {
		mp_mem_ctl= state->fiu_pa026d & 0xf;
	}
	bool inc_mar = (state->fiu_prmt >> 3) & 1;
	state->fiu_page_crossing_next = (
		mp_cond_sel != 0x6a) && (// sel_pg_xing
		mp_cond_sel != 0x6e) && (// sel_incyc_px
		(
			(state->fiu_page_xing) ||
			(!state->fiu_page_xing && inc_mar && (state->fiu_moff & 0x1f) == 0x1f)
		)
	);
	mp_mem_continue= !((state->fiu_pa025d >> 5) & 1);
	state->fiu_uev10_page_x = !(mp_uevent_enable && state->fiu_page_xing);
	if (mp_uevent_enable && state->fiu_page_xing) {
		mp_seq_uev |= UEV_PAGE_X;
	} else {
		mp_seq_uev &= ~UEV_PAGE_X;
	}
	state->fiu_uev0_memex = !(mp_uevent_enable && state->fiu_memex);
	if (mp_uevent_enable && state->fiu_memex) {
		mp_seq_uev |= UEV_MEMEX;
	} else {
		mp_seq_uev &= ~UEV_MEMEX;
	}
	mp_clock_stop_0 = state->fiu_uev10_page_x && state->fiu_uev0_memex;
	//fiu_conditions();
	tcsa(false);
	if ((!mp_fiut_oe || !mp_fiuv_oe)) {
		do_tivi();
		if (!mp_fiut_oe) {
			mp_typ_bus = ~state->fiu_ti_bus;
		}
		if (!mp_fiuv_oe) {
			mp_val_bus = ~state->fiu_vi_bus;
		}
	}
}

void
r1000_arch ::
fiu_q4(void)
{
	bool sclk = !mp_state_clk_en;
	bool tcsa_clk = (mp_clock_stop && mp_ram_stop && !mp_freeze);
	unsigned mar_cntl = mp_mar_cntl;
	bool rmarp = (mar_cntl & 0xe) == 0x4;
	bool carry, name_match;

	unsigned csa = mp_csa_cntl;
	unsigned pa028a = mp_mar_cntl << 5;
	pa028a |= state->fiu_incmplt_mcyc << 4;
	pa028a |= state->fiu_e_abort_dly << 3;
	pa028a |= state->fiu_state1 << 2;
	pa028a |= state->fiu_mctl_is_read << 1;
	pa028a |= state->fiu_dumon;
	state->fiu_prmt = fiu_pa028[pa028a];
	state->fiu_prmt ^= 0x02;
	state->fiu_prmt &= 0x7b;


	do_tivi();
	tcsa(tcsa_clk);
	if (sclk) {
		if (UIR_FIU_LDMDR || !UIR_FIU_TCLK || !UIR_FIU_VCLK) {
			rotator(sclk);
		}

		if (!UIR_FIU_OCLK) {			// Q4~^
			if (UIR_FIU_ORSR) {			// UCODE
				state->fiu_oreg = UIR_FIU_OL;
			} else {
				state->fiu_oreg = mp_adr_bus & 0x7f;
			}
		}

		if (mar_cntl == 5) {
			state->fiu_refresh_reg = state->fiu_ti_bus;
			state->fiu_marh &= 0xffffffffULL;
			state->fiu_marh |= (state->fiu_refresh_reg & 0xffffffff00000000ULL);
			state->fiu_marh ^= 0xffffffff00000000ULL;
		}

		unsigned lfrc;
		lfrc = UIR_FIU_LFRC;

		switch(lfrc) {
		case 0:
			state->fiu_lfreg = (((state->fiu_vi_bus >> BUS64_LSB(31)) & 0x3f) + 1) & 0x3f;
			if ((state->fiu_ti_bus >> BUS64_LSB(36)) & 1)
				state->fiu_lfreg |= (1 << 6);
			else if (!((state->fiu_vi_bus >> BUS64_LSB(25)) & 1))
				state->fiu_lfreg |= (1 << 6);
			state->fiu_lfreg ^= 0x7f;
			break;
		case 1:
			state->fiu_lfreg = UIR_FIU_LFL;
			break;
		case 2:
			state->fiu_lfreg = (state->fiu_ti_bus >> BUS64_LSB(48)) & 0x3f;
			if ((state->fiu_ti_bus >> BUS64_LSB(36)) & 1)
				state->fiu_lfreg |= (1 << 6);
			state->fiu_lfreg = state->fiu_lfreg ^ 0x7f;
			break;
		case 3:	// No load
			break;
		}

		state->fiu_marh &= ~(0x3fULL << 15);
		state->fiu_marh |= (state->fiu_lfreg & 0x3f) << 15;
		state->fiu_marh &= ~(1ULL << 27);
		state->fiu_marh |= ((state->fiu_lfreg >> 6) & 1) << 27;
		if (state->fiu_lfreg != 0x7f)
			state->fiu_lfreg |= 1<<7;

{
		unsigned csacntl0 = (state->fiu_typwcsram[mp_nua_bus] >> 1) & 7;
		unsigned csacntl1 = (state->fiu_typuir >> 1) & 6;
		state->fiu_pdt = (csacntl0 == 7) && (csacntl1 == 0);
}
		state->fiu_nve = mp_csa_nve;
		if (!(csa >> 2)) {
			state->fiu_pdreg = state->fiu_ctopo;
		}
	}

	unsigned dif;

	if (state->fiu_pdt) {
		carry = state->fiu_ctopo <= state->fiu_pdreg;
		dif = ~0xfffff + state->fiu_pdreg - state->fiu_ctopo;
	} else {
		carry = state->fiu_moff <= state->fiu_ctopo;
		dif = ~0xfffff + state->fiu_ctopo - state->fiu_moff;
	}
	dif &= 0xfffff;

	name_match = 
		    (state->fiu_ctopn != state->fiu_srn) ||
		    ((state->fiu_sro & 0xf8000070 ) != 0x10);

	state->fiu_in_range = (!state->fiu_pdt && name_match) || (dif & 0xffff0);

	state->fiu_hit_offset = (0xf + state->fiu_nve - (dif & 0xf)) & 0xf;

	uint64_t adr = 0;
	adr = mp_adr_bus;
	bool load_mar = (state->fiu_prmt >> 4) & 1;
			
	if (sclk && load_mar) {
		state->fiu_srn = adr >> 32;
		state->fiu_sro = adr & 0xffffff80;
		state->fiu_sro |= mp_spc_bus << 4;
		state->fiu_sro |= 0xf;
	}
	state->fiu_moff = (state->fiu_sro >> 7) & 0xffffff;
			
	state->fiu_nmatch =
	    (state->fiu_ctopn != state->fiu_srn) ||
	    ((state->fiu_sro & 0xf8000070 ) != 0x10);
			
	if (sclk && (csa == 0)) {
		state->fiu_ctopn = adr >> 32;
		state->fiu_nmatch =
		    (state->fiu_ctopn != state->fiu_srn) ||
		    ((state->fiu_sro & 0xf8000070 ) != 0x10);
	}
			
	if (sclk && !(csa >> 2)) {
		if (csa <= 1) {
			state->fiu_ctopo = adr >> 7;
		} else if (!(csa & 1)) {
			state->fiu_ctopo += 1;
		} else {
			state->fiu_ctopo += 0xfffff;
		}
		state->fiu_ctopo &= 0xfffff;
			
	}
			
	if (state->fiu_mem_start == 0x06) {
		mp_refresh_count = state->fiu_ti_bus >> 48;
	} else if (mp_refresh_count != 0xffff) {
		mp_refresh_count++;
	}

	bool le_abort = mp_mem_abort_el;
	bool e_abort = mp_mem_abort_e;
	bool eabrt = !(e_abort && le_abort);
	bool l_abort = mp_mem_abort_l;
	bool idum;
	bool sel = !((!mp_state_clk_stop && state->fiu_memcyc1) || (mp_state_clk_en && !state->fiu_memcyc1));
	if (sel) {
		idum = (state->fiu_prmt >> 5) & 1;
	} else {
		idum = state->fiu_dumon;
	}
	state->fiu_state0 = (state->fiu_pa025d >> 7) & 1;
	state->fiu_state1 = (state->fiu_pa025d >> 6) & 1;
	state->fiu_labort = !(l_abort && le_abort);
	state->fiu_e_abort_dly = eabrt;
	state->fiu_pcntl_d = state->fiu_pa026d & 0xf;
	state->fiu_dumon = idum;
	state->fiu_csaht = !mp_csa_hit;

	if (!mp_sf_stop) {
		bool cache_miss_next = state->fiu_cache_miss;
		if (mp_cond_sel == 0x6b) {		// CACHE_MISS
			cache_miss_next = false;
		} else if (rmarp) {
			cache_miss_next = (state->fiu_ti_bus >> BUS64_LSB(35)) & 1;
		} else if (state->fiu_log_query) {
			cache_miss_next = state->fiu_miss;
		}
		state->fiu_scav_trap = state->fiu_scav_trap_next;
		state->fiu_cache_miss = cache_miss_next;
		state->fiu_csa_oor = state->fiu_tmp_csa_oor_next;
								
		if (rmarp) {
			state->fiu_mar_modified = (state->fiu_ti_bus >> BUS64_LSB(39)) & 1;
		} else if (mp_cond_sel == 0x6d) {
			state->fiu_mar_modified = 1;
		} else if (state->fiu_omf20) {
			state->fiu_mar_modified = le_abort;
		} else if (!state->fiu_memstart && le_abort) {
			state->fiu_mar_modified = le_abort;
		}
		if (rmarp) {
			state->fiu_incmplt_mcyc = (state->fiu_ti_bus >> BUS64_LSB(40)) & 1;
		} else if (state->fiu_mem_start == 0x12) {
			state->fiu_incmplt_mcyc = true;
		} else if (state->fiu_memcyc1) {
			state->fiu_incmplt_mcyc = le_abort;
		}
		if (rmarp) {
			state->fiu_phys_last = (state->fiu_ti_bus >> BUS64_LSB(37)) & 1;
			state->fiu_write_last = (state->fiu_ti_bus >> BUS64_LSB(38)) & 1;
		} else if (state->fiu_memcyc1) {
			state->fiu_phys_last = state->fiu_phys_ref;
			state->fiu_write_last = (state->fiu_mcntl & 1);
		}
								
		state->fiu_log_query = !(state->fiu_labort || state->fiu_logrwn);
										
		state->fiu_omf20 = (state->fiu_memcyc1 && ((state->fiu_prmt >> 3) & 1) && !mp_state_clk_en);
		
		if (state->fiu_memcyc1)
			state->fiu_mctl_is_read = !(state->fiu_lcntl & 1);
		else
			state->fiu_mctl_is_read = !(state->fiu_pa026d & 1);
								
		state->fiu_logrw_d = state->fiu_logrw;
	}

	if (!mp_state_clk_en) {
		state->fiu_omq = 0;
		state->fiu_omq |= (state->fiu_pa027d & 3) << 2;
		state->fiu_omq |= ((state->fiu_pa027d >> 5) & 1) << 1;
		if (rmarp) {
			state->fiu_page_xing = (state->fiu_ti_bus >> BUS64_LSB(34)) & 1;
		} else {
			state->fiu_page_xing = (state->fiu_page_crossing_next);
		}
		state->fiu_init_mru_d = (state->fiu_pa026d >> 7) & 1;
	}
	state->fiu_csa_oor_next = !(carry || name_match);

	if (!mp_sf_stop) {
		state->fiu_uir = state->fiu_wcsram[mp_nua_bus];
		state->fiu_typuir = state->fiu_typwcsram[mp_nua_bus];
	}
}


// -------------------- SEQ --------------------

void
r1000_arch ::
int_reads()
{
	unsigned internal_reads = UIR_SEQ_IRD;
	switch (state->seq_urand & 3) {
	case 3:	state->seq_coff = state->seq_retrn_pc_ofs; break;
	case 2: state->seq_coff = branch_offset(); break;
	case 1: state->seq_coff = state->seq_macro_pc_offset; break;
	case 0: state->seq_coff = branch_offset(); break;
	}
	state->seq_coff ^= 0x7fff;
	if (internal_reads == 0) {
		state->seq_typ_bus = ~mp_typ_bus;
		state->seq_val_bus = ~mp_val_bus;
		return;
	}		

	state->seq_typ_bus = state->seq_n_in_csa;
	state->seq_typ_bus |= state->seq_output_ob << 7;
	state->seq_typ_bus ^= 0xffffffff;

	switch (internal_reads) {
	case 5:
		state->seq_typ_bus |= (state->seq_name_bus ^ 0xffffffff) << 32;
		break;
	default:
		state->seq_typ_bus |= (uint64_t)state->seq_cur_name << 32;
		break;
	}
	
	if (!(state->seq_urand & 0x2)) {
		state->seq_val_bus = state->seq_pcseg << 32;
	} else {
		state->seq_val_bus = state->seq_retseg << 32;
	}
	state->seq_val_bus ^= 0xffffffffULL << 32; 
	state->seq_val_bus ^= (state->seq_coff >> 12) << 16;
	state->seq_val_bus ^= 0xffffULL << 16; 
	switch (internal_reads) {
	case 1:
		state->seq_val_bus |= state->seq_curins ^ 0xffff;
		break;
	case 2:
		state->seq_val_bus |= state->seq_display;
		break;
	case 3:
		state->seq_val_bus |= state->seq_topu & 0xffff;
		break;
	default:
		state->seq_val_bus |= (state->seq_coff << 4) & 0xffff;
		state->seq_val_bus |= (state->seq_curr_lex & 0xf);
		state->seq_val_bus ^= 0xffff;
		break;
	}
}

unsigned
r1000_arch ::
group_sel(void)
{
	static uint8_t tbl[16] = {3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 0, 1, 1, 1, 0};

	unsigned retval = tbl[state->seq_br_type];
	if (state->seq_uadr_mux) {
		retval |= 4;
	}
	return (retval);
}

unsigned
r1000_arch ::
late_macro_pending(void)
{
	unsigned csa = mp_csa_nve;
	unsigned dec = state->seq_decode >> 3;

	if (csa < (dec & 7))
		return (0);
	if (csa > ((dec >> 3) | 12))
		return (1);
	if (state->seq_stop)
		return (2);
	if (!state->seq_m_res_ref)
		return (3);
	if (!state->seq_m_tos_invld)
		return (4);
	if (!state->seq_m_break_class)
		return (6);
	if (!state->seq_m_ibuff_mt)
		return (7);
	return (8);
}

bool
r1000_arch ::
seq_conda(unsigned condsel)
{

	switch (condsel) {
	case 0x57: // FIELD_NUM_ERR
		return (!state->seq_field_number_error);
	case 0x56: // LATCHED_COND
		return (!state->seq_latched_cond);
	case 0x55: // E_MACRO_PEND
		return (!state->seq_early_macro_pending);
	case 0x54: // E_MACRO_EVNT~6
		return (!((state->seq_emac >> 0) & 1));
	case 0x53: // E_MACRO_EVNT~5
		return (!((state->seq_emac >> 1) & 1));
	case 0x52: // E_MACRO_EVNT~3
		return (!((state->seq_emac >> 3) & 1));
	case 0x51: // E_MACRO_EVNT~2
		return (!((state->seq_emac >> 4) & 1));
	case 0x50: // E_MACRO_EVNT~0
		return (!((state->seq_emac >> 6) & 1));
	default:
		return (false);
	}
}

bool
r1000_arch ::
seq_cond9(unsigned condsel)
{

	switch (condsel) {
	case 0x4f: // DISP_COND0
		return ((state->seq_decode & 0x7) == 0);
		break;
	case 0x4e: // True
		return (true);
		break;
	case 0x4d: // M_IBUFF_MT
		return (state->seq_m_ibuff_mt);
		break;
	case 0x4c: // M_BRK_CLASS
		return (state->seq_m_break_class);
		break;
	case 0x4b: // M_TOS_INVLD
		return (state->seq_m_tos_invld);
		break;
	case 0x4a: // M_RES_REF
		return (state->seq_m_res_ref);
		break;
	case 0x49: // M_OVERFLOW
		{
		unsigned csa = mp_csa_nve;
		unsigned dec = state->seq_decode >> 3;
		return (csa <= ((dec >> 3) | 12));
		}
		break;
	case 0x48: // M_UNDERFLOW
		{
		unsigned csa = mp_csa_nve;
		unsigned dec = state->seq_decode >> 3;
		return (csa >= (dec & 7));
		}
		break;
	default:
		return (false);
	}
}

bool
r1000_arch ::
seq_cond8(unsigned condsel)
{

	switch (condsel) {
	case 0x47: // STACK_SIZE
		return (state->seq_stack_size_zero);
		break;
	case 0x46: // LATCHED_COND
		return (state->seq_latched_cond);
		break;
	case 0x45: // SAVED_LATCHED
		return (state->seq_saved_latched);
		break;
	case 0x44: // TOS_VLD.COND
		return (state->seq_tos_vld_cond);
		break;
	case 0x43: // LEX_VLD.COND
		return (state->seq_lxval);
		break;
	case 0x42: // IMPORT.COND
		return (state->seq_import_condition);
		break;
	case 0x41: // REST_PC_DEC
		return ((state->seq_rq >> 1) & 1);
		break;
	case 0x40: // RESTARTABLE
		return ((state->seq_rq >> 3) & 1);
		break;
	default:
		return (false);
	}
}

void
r1000_arch ::
nxt_lex_valid(void)
{
	unsigned lex_random;
	uint16_t dns;
	uint16_t dra;
	uint16_t dlr;
	lex_random = (state->seq_rndx >> 5) & 0x7;
	dra = state->seq_resolve_address & 3;
	dlr = lex_random;
	if (lex_random & 0x2) {
		dns = 0xf;
	} else {
		dns = 0xf ^ (0x8 >> (state->seq_resolve_address >> 2));
	}
	unsigned adr;
	uint16_t nv = 0;
	adr = ((state->seq_lex_valid >> 12) & 0xf) << 5;
	adr |= dra << 3;
	adr |= ((dlr >> 2) & 1) << 2;
	adr |= ((dns >> 3) & 1) << 1;
	bool pm3 = !((dns & 0x7) && !(dlr & 1));
	adr |= pm3;
	nv |= (seq_pa041[adr] >> 4) << 12;

	adr = ((state->seq_lex_valid >> 8) & 0xf) << 5;
	adr |= dra << 3;
	adr |= ((dlr >> 2) & 1) << 2;
	adr |= ((dns >> 2) & 1) << 1;
	bool pm2 = !((dns & 0x3) && !(dlr & 1));
	adr |= pm2;
	nv |= (seq_pa041[adr] >> 4) << 8;

	adr = ((state->seq_lex_valid >> 4) & 0xf) << 5;
	adr |= dra << 3;
	adr |= ((dlr >> 2) & 1) << 2;
	adr |= ((dns >> 1) & 1) << 1;
	bool pm1 = !((dns & 0x1) && !(dlr & 1));
	adr |= pm1;
	nv |= (seq_pa041[adr] >> 4) << 4;

	adr = ((state->seq_lex_valid >> 0) & 0xf) << 5;
	adr |= dra << 3;
	adr |= ((dlr >> 2) & 1) << 2;
	adr |= ((dns >> 0) & 1) << 1;
	adr |= (dlr >> 0) & 1;
	nv |= (seq_pa041[adr] >> 4) << 0;

	state->seq_lex_valid = nv;
}

bool
r1000_arch ::
condition(void)
{
	unsigned condsel = UIR_SEQ_CSEL;

	switch (condsel >> 3) {
	case 0x0: return(mp_condxf);
	case 0x1: return(mp_condxe);
	case 0x2: return(mp_condxd);
	case 0x3: return(mp_condxc);
	case 0x4: return(mp_condxb);
	case 0x5: return(mp_condxa);
	case 0x6: return(mp_condx9);
	case 0x7: return(mp_condx8);
	case 0x8: return(seq_cond8(condsel));
	case 0x9: return(seq_cond9(condsel));
	case 0xa: return(seq_conda(condsel));
	case 0xb: return(!(mp_condxc && mp_condxf));
	case 0xc: return(fiu_conditions());
	case 0xd: return(fiu_conditions());
	case 0xf: return(ioc_cond());
	default: return(1);
	}
}

unsigned
r1000_arch ::
branch_offset(void)
{
	bool oper;
	unsigned a;
	if (!state->seq_wanna_dispatch && !state->seq_m_ibuff_mt) {
		a = 0;
		oper = true;
	} else if (!state->seq_wanna_dispatch && state->seq_m_ibuff_mt) {
		a = state->seq_display;
		oper = false;
	} else if (state->seq_wanna_dispatch && !state->seq_m_ibuff_mt) {
		a = state->seq_curins;
		oper = true;
	} else {
		a = state->seq_curins;
		oper = true;
	}
	a &= 0x7ff;
	if (a & 0x400)
		a |= 0x7800;
	a ^= 0x7fff;
	unsigned b = state->seq_macro_pc_offset & 0x7fff;
	unsigned retval;
	if (oper) {
		if (state->seq_wanna_dispatch)
			a += 1;
		a &= 0x7fff;
		retval = a + b;
	} else {
		if (!state->seq_wanna_dispatch)
			a += 1;
		retval = b - a;
	}
	retval &= 0x7fff;
	return (retval);
}

void
r1000_arch ::
q3clockstop(void)
{
	bool event = true;
	mp_state_clk_stop = true;
	state->seq_s_state_stop = true;
	mp_clock_stop = true;
	mp_ram_stop = true;

	if (mp_seq_halted && mp_seq_prepped) {
		state->seq_diag |= 0x01;
		mp_sync_freeze |= 1;
	} else {
		state->seq_diag &= ~0x01;
		mp_sync_freeze &= ~1;
	}

	if (mp_fiu_freeze && !(state->seq_diag & 0x2)) {
		state->seq_diag |= 0x02;
		// output.freze = 1;
		mp_sync_freeze |= 2;
		ALWAYS_TRACE(<< "THAW1 " << state->seq_diag << " " << mp_sync_freeze);
	} else if (!mp_fiu_freeze && (state->seq_diag & 0x2) && !(state->seq_diag & 0x4)) {
		state->seq_diag |= 0x04;
		// output.sync = 1;
		mp_sync_freeze |= 4;
		ALWAYS_TRACE(<< "THAW2 " << state->seq_diag << " " << mp_sync_freeze);
	} else if (!mp_fiu_freeze && (state->seq_diag & 0x2) && (state->seq_diag & 0x4)) {
		state->seq_diag &= ~0x02;
		// output.freze = 0;
		mp_sync_freeze &= ~2;
		state->seq_countdown = 5;
		ALWAYS_TRACE(<< "THAW3 " << (state->seq_diag & 0x2) << " " << mp_sync_freeze << " " << state->seq_countdown);
	} else if (!mp_fiu_freeze && !(state->seq_diag & 0x2) && (state->seq_diag & 0x4)) {
		if (--state->seq_countdown == 0) {
			// output.sync = 0;
			state->seq_diag &= ~0x04;
			mp_sync_freeze &= ~4;
		}
		ALWAYS_TRACE(<< "THAW4 " <<  state->seq_diag << " " << mp_sync_freeze << " " << state->seq_countdown);
	}

	state->seq_sf_stop = !(state->seq_diag == 0);
	mp_sf_stop = !(state->seq_diag == 0);
	mp_freeze = (state->seq_diag & 3) != 0;

	unsigned clock_stop = 0;
	state->seq_clock_stop_1 = !(mp_clock_stop_6 && mp_clock_stop_7 && mp_below_tcp);
	if (    mp_clock_stop_0) { clock_stop |= 0x40; }
	if (state->seq_clock_stop_1) { clock_stop |= 0x20; }
	if (    mp_clock_stop_3) { clock_stop |= 0x10; }
	if (    mp_clock_stop_4) { clock_stop |= 0x08; }
	if (state->seq_clock_stop_5) { clock_stop |= 0x04; }
	if (mp_clock_stop_6) { clock_stop |= 0x02; }
	if (mp_clock_stop_7) { clock_stop |= 0x01; }
	
	if ((clock_stop | 0x01) != 0x7f) {
		mp_state_clk_stop = false;
		event = false;
	}
	if (clock_stop != 0x7f) {
		mp_clock_stop = false;
		if (!mp_csa_write_enable) {
			mp_ram_stop = false;
		}
	}
	if ((clock_stop | 0x03) != 0x7f) {
		state->seq_s_state_stop = false;
	}

	if (state->seq_sf_stop) {
		mp_clock_stop = false;
		mp_state_clk_stop = false;
		state->seq_s_state_stop = false;
		if (!mp_csa_write_enable) {
			mp_ram_stop = false;
		}
	}
	mp_state_clk_en= !(mp_state_clk_stop && mp_clock_stop_7);
	mp_mem_abort_el = event;
}

void
r1000_arch ::
seq_p1(void)
{
	int_reads();
	unsigned lex_adr = UIR_SEQ_LAUIR;

	if (state->seq_maybe_dispatch && !(state->seq_display >> 15)) {
		switch (lex_adr) {
		case 0:	state->seq_resolve_address = (state->seq_display >> 9) & 0xf; break;
		case 1: state->seq_resolve_address = 0xf; break;
		case 2: state->seq_resolve_address = 0xf; break;
		case 3: state->seq_resolve_address = 0xe; break;
		}
	} else {
		switch (lex_adr) {
		case 0:	state->seq_resolve_address = state->seq_curr_lex ^ 0xf; break;
		case 1:
			state->seq_resolve_address = (state->seq_val_bus & 0xf) + 1; 
			break;
		case 2: state->seq_resolve_address = 0xf; break;
		case 3: state->seq_resolve_address = 0xe; break;
		}
	}
	
	state->seq_resolve_address &= 0xf;
	if (lex_adr == 1) {
		state->seq_import_condition = true;
		state->seq_sign_extend = true;
	} else {
		state->seq_import_condition = state->seq_resolve_address != 0xf;
		state->seq_sign_extend = state->seq_resolve_address <= 0xd;
	}

	state->seq_lxval = !((state->seq_lex_valid >> (15 - state->seq_resolve_address)) & 1);

	unsigned uses_tos;
	if (!state->seq_maybe_dispatch) {
		uses_tos = false;
		state->seq_mem_start = 7;
		state->seq_intreads = UIR_SEQ_IRD & 3;
	} else {
		uses_tos = state->seq_uses_tos;
		state->seq_mem_start = state->seq_decode & 0x7;
		if (state->seq_mem_start == 0 || state->seq_mem_start == 4) {
			state->seq_intreads = 3;
		} else {
			state->seq_intreads = 1;
		}
	}

	unsigned offs;
	if (uses_tos) {
		if (RNDX(RND_TOS_VLB)) {
			offs = (state->seq_typ_bus >> 7) & 0xfffff;
		} else {
			offs = state->seq_tosof;
		}
	} else {
		offs = state->seq_tosram[state->seq_resolve_address];
	}
	offs ^= 0xfffff;
	offs &= 0xfffff;

	bool d7 = (state->seq_display & 0x8100) == 0;
	unsigned sgdisp = state->seq_display & 0xff;
	if (!d7)
		sgdisp |= 0x100;
	if (!(state->seq_sign_extend && d7))
		sgdisp |= 0xffe00;

	bool acin = ((state->seq_mem_start & 1) != 0);
	sgdisp &= 0xfffff;
	state->seq_resolve_offset = 0;

	switch(state->seq_mem_start) {
	case 0:
	case 2:
		state->seq_resolve_offset = offs + sgdisp + 1;
		state->seq_tmp_carry_out = (state->seq_resolve_offset >> 20) == 0;
		break;
	case 1:
	case 3:
		state->seq_resolve_offset = (1<<20) + offs - (sgdisp + 1);
		state->seq_tmp_carry_out = acin && (offs == 0);
		break;
	case 4:
	case 6:
		state->seq_resolve_offset = sgdisp ^ 0xfffff;
		// Carry is probably "undefined" here.
		break;
	case 5:
	case 7:
		state->seq_resolve_offset = offs;
		state->seq_tmp_carry_out = acin && (offs == 0);
		break;
	}

	state->seq_resolve_offset &= 0xfffff;

	if (state->seq_intreads == 3) {
		state->seq_output_ob = state->seq_pred;
	} else if (state->seq_intreads == 2) {
		state->seq_output_ob = state->seq_topcnt;
	} else if (state->seq_intreads == 1) {
		state->seq_output_ob = state->seq_resolve_offset;
	} else if (state->seq_intreads == 0) {
		state->seq_output_ob = state->seq_savrg;
	} else {
		state->seq_output_ob = 0xfffff;
	}
	state->seq_output_ob &= 0xfffff;
	if (!state->seq_maybe_dispatch) {
		state->seq_name_bus = state->seq_namram[state->seq_resolve_address] ^ 0xffffffff;
	} else {
		state->seq_name_bus = 0xffffffff;
	}
	state->seq_cload = RNDX(RND_CIB_PC_L) && (!state->seq_bad_hint) && (!condition());
	bool ibuff_ld = !(state->seq_cload || RNDX(RND_IBUFF_LD));
	state->seq_ibld = !ibuff_ld;
	bool ibemp = !(ibuff_ld || (state->seq_word != 0));
	state->seq_m_ibuff_mt = !(ibemp && state->seq_ibuf_fill);

}

void
r1000_arch ::
seq_h1(void)
{

	state->seq_urand = UIR_SEQ_URAND;
	state->seq_rndx = seq_pa048[state->seq_urand | (state->seq_bad_hint ? 0x100 : 0)] << 24;
	state->seq_rndx |= seq_pa046[state->seq_urand | (state->seq_bad_hint ? 0x100 : 0)] << 16;
	state->seq_rndx |=  seq_pa045[state->seq_urand | 0x100] << 8;
	state->seq_rndx |= seq_pa047[state->seq_urand | 0x100];

	state->seq_br_type = UIR_SEQ_BRTYP;
	state->seq_maybe_dispatch = 0xb < state->seq_br_type && state->seq_br_type < 0xf;

	if (mp_fiu_oe == 0x8)
		mp_fiu_bus = state->seq_topu;
	if (!mp_seqtv_oe) {
		seq_p1();
		int_reads();	// Necessary
		mp_typ_bus = ~state->seq_typ_bus;
		mp_val_bus = ~state->seq_val_bus;
	}
}

void
r1000_arch ::
seq_q1(void)
{
	seq_p1();
	state->seq_br_tim = UIR_SEQ_BRTIM;
	if (state->seq_bad_hint) {
		state->seq_uadr_mux = ((state->seq_bhreg) >> 5) & 1;
	} else {
		switch (state->seq_br_tim) {
		case 0: state->seq_uadr_mux = !condition(); break;
		case 1: state->seq_uadr_mux = !state->seq_latched_cond; break;
		case 2: state->seq_uadr_mux = false; break;
		case 3: state->seq_uadr_mux = true; break;
		}
		if (state->seq_br_type & 1)
			state->seq_uadr_mux = !state->seq_uadr_mux;
	}

	unsigned adr = 0;
	if (state->seq_bad_hint) adr |= 0x01;
	adr |= (state->seq_br_type << 1);
	if (state->seq_bhreg & 0x20) adr |= 0x20;
	if (state->seq_bhreg & 0x40) adr |= 0x80;
	if (state->seq_bhreg & 0x80) adr |= 0x100;
	unsigned rom = seq_pa043[adr];
	state->seq_wanna_dispatch = !(((rom >> 5) & 1) && !state->seq_uadr_mux);	// Changes @15, 20, 60ns
	state->seq_preturn = !(((rom >> 3) & 1) ||  state->seq_uadr_mux);
	state->seq_push_br =    (rom >> 1) & 1;
	state->seq_push   = !(((rom >> 0) & 1) || !(((rom >> 2) & 1) || !state->seq_uadr_mux));
	state->seq_stop = !(!state->seq_bad_hint && (state->seq_uev == 16) && !state->seq_late_macro_event);
	bool evnan0d = !(UIR_SEQ_ENMIC && (state->seq_uev == 16));
	mp_uevent_enable = !(evnan0d || state->seq_stop);
}

void
r1000_arch ::
seq_q2(void)
{
	state->seq_tos_vld_cond = !(state->seq_foo7 || RNDX(RND_TOS_VLB));				// cond, q4
	state->seq_m_tos_invld = !(state->seq_uses_tos && state->seq_tos_vld_cond);				// lmp, cond

	state->seq_check_exit_ue = !(mp_uevent_enable && RNDX(RND_CHK_EXIT) && state->seq_carry_out);	// q4
	state->seq_m_res_ref = !(state->seq_lxval && !(state->seq_display >> 15));				// lmp, cond

	uint64_t val = state->seq_val_bus >> 32;
	val &= 0xffffff;

	unsigned tmp = (val >> 7) ^ state->seq_curins;
	tmp &= 0x3ff;
	state->seq_field_number_error = tmp != 0x3ff;
	state->seq_ferr = !(state->seq_field_number_error && !(RNDX(RND_FLD_CHK) || !mp_uevent_enable));

	state->seq_ram[(state->seq_adr + 1) & 0xf] = state->seq_topu;

	state->seq_l_macro_hic = true;
	unsigned nua;
	if (state->seq_bad_hint) {
		nua = state->seq_other;
	} else if (state->seq_late_macro_event) {
		// Not tested by expmon_test_seq ?
		nua = state->seq_late_u << 3;
		nua ^= (7 << 3);
		nua |= 0x0140;
		state->seq_l_macro_hic = false;
	} else if (state->seq_uev != 16) {
		nua = state->seq_uev;
		nua <<= 3;
		nua |= 0x0180;
	} else {
		unsigned sel = group_sel();
		switch (sel) {
		case 0:
			nua = UIR_SEQ_BRN;
			nua += state->seq_fiu;
			break;
		case 1:
			nua = state->seq_uadr_decode >> 3;
			nua <<= 1;
			break;
		case 2:
			nua = (state->seq_topu ^ 0xffff) & 0x3fff;
			break;
		case 3:
		case 4:
			nua = mp_cur_uadr;
			nua += 1;
			break;
		case 5:
		case 6:
		case 7:
			nua = UIR_SEQ_BRN;
			break;
		default:
			nua = 0;
			assert(sel < 8);
			break;
		}
	}
	if (!state->seq_sf_stop && mp_seq_prepped) {
		mp_nua_bus = nua & 0x3fff;
	}
	state->seq_clock_stop_5 = (state->seq_check_exit_ue && state->seq_ferr);
	mp_clock_stop_6 = !(!state->seq_bad_hint && !state->seq_late_macro_event && state->seq_uev != 16);
	mp_clock_stop_7 = !state->seq_bad_hint && state->seq_l_macro_hic;
	mp_state_clk_en = !(mp_state_clk_stop && mp_clock_stop_7);
}

void
r1000_arch ::
seq_q3(void)
{
	q3clockstop();
	int_reads();
	state->seq_q3cond = condition();
	state->seq_bad_hint_enable = !((!mp_clock_stop_6) || (state->seq_late_macro_event && !state->seq_bad_hint));
	unsigned pa040a = 0;
	pa040a |= (state->seq_decode & 0x7) << 6;
	if (state->seq_wanna_dispatch) pa040a |= 0x20;
	if (RNDX(RND_ADR_SEL)) pa040a |= 0x10;
	if (state->seq_import_condition) pa040a |= 0x08;
	if (state->seq_stop) pa040a |= 0x04;
	if (!state->seq_maybe_dispatch) pa040a |= 0x02;
	if (state->seq_bad_hint) pa040a |= 0x01;
	unsigned pa040d = seq_pa040[pa040a];

	bool bar8;
	state->seq_lmp = late_macro_pending();
	state->seq_macro_event = (!state->seq_wanna_dispatch) && (state->seq_early_macro_pending || (state->seq_lmp != 8));
	if (state->seq_macro_event) {
		bar8 = (state->seq_macro_event && !state->seq_early_macro_pending) && (state->seq_lmp >= 7);
	} else {
		bar8 = !((pa040d >> 1) & 1);
	}

	if (!bar8) {
		mp_mem_abort_e = false;
	} else if (mp_mem_cond) {
		mp_mem_abort_e = true;
	} else if (mp_mem_cond_pol ^ state->seq_q3cond) {
		mp_mem_abort_e = true;
	} else {
		mp_mem_abort_e = false;
	}

	if (RNDX(RND_TOS_VLB) && !state->seq_stop) {
		state->seq_tost = state->seq_typ_bus >> 32;
		state->seq_vost = state->seq_val_bus >> 32;
		state->seq_tosof = (state->seq_typ_bus >> 7) & 0xfffff;
	}
	if (state->seq_maybe_dispatch) {
		switch (state->seq_mem_start) {
		case 0:
		case 1:
		case 2:
			state->seq_name_bus = state->seq_namram[state->seq_resolve_address] ^ 0xffffffff;
			break;
		case 3:
		case 7:
			state->seq_name_bus = state->seq_tost ^ 0xffffffff;
			break;
		default:
			state->seq_name_bus = state->seq_vost ^ 0xffffffff;
			break;
		}
	} else {
		state->seq_name_bus = state->seq_namram[state->seq_resolve_address] ^ 0xffffffff;
	}
	if (!(state->seq_foo9 || mp_clock_stop_6)) {
		state->seq_treg = 0;
		state->seq_foo7 = false;
	}
	if (mp_adr_oe & 0x8) {
		if (state->seq_macro_event) {
			mp_spc_bus = 0x6;
		} else {
			mp_spc_bus = (pa040d >> 3) & 0x7;
		}
		bool adr_is_code = !((!state->seq_macro_event) && (pa040d & 0x01));
		bool resolve_drive;
		if (!state->seq_macro_event) {
			resolve_drive = !((pa040d >> 6) & 1);
		} else {
			resolve_drive = true;
		}
		if (!resolve_drive) {
			mp_adr_bus = state->seq_resolve_offset << 7;
		} else if (adr_is_code) {
			mp_adr_bus = (state->seq_coff >> 3) << 7;
		} else {
			mp_adr_bus = state->seq_output_ob << 7;
		}

		uint64_t branch;
		branch = branch_offset() & 7;
		branch ^= 0x7;
		mp_adr_bus |= branch << 4;
		if (!adr_is_code) {
			mp_adr_bus |= state->seq_name_bus << 32;
		} else if (!(state->seq_urand & 0x2)) {
			mp_adr_bus |= state->seq_pcseg << 32; 
		} else {
			mp_adr_bus |= state->seq_retseg << 32;
		}
	}
	bool bad_hint_disp = (!state->seq_bad_hint || (state->seq_bhreg & 0x08));
	mp_mem_abort_l = bad_hint_disp && !(RNDX(RND_L_ABRT) && !state->seq_stop);
}

void
r1000_arch ::
seq_q4(void)
{
	bool aclk = !state->seq_sf_stop;
	bool sclke = !(state->seq_s_state_stop && !state->seq_stop);
	bool sclk = aclk && !sclke;
	bool state_clock = !sclke;

	bool bhen = !((state->seq_late_macro_event && !state->seq_bad_hint) || (!mp_clock_stop_6));
	bool bhcke = !(state->seq_s_state_stop && bhen);
	if (state_clock) {
		nxt_lex_valid();
	}
	bool dispatch = state->seq_wanna_dispatch || state->seq_early_macro_pending || (state->seq_lmp != 8);
	if (state_clock && !RNDX(RND_RES_OFFS)) {
		state->seq_tosram[state->seq_resolve_address] = (state->seq_typ_bus >> 7) & 0xfffff;
	}
	if (aclk) {
		state->seq_late_macro_event = !(sclke || !(state->seq_macro_event && !state->seq_early_macro_pending));
		if (!mp_seq_halted) {
			mp_seq_halted = !(sclke || RNDX(RND_HALT));
			if (mp_seq_halted) ALWAYS_TRACE(<< "THAW HALTED");
		}
	}
	if (state_clock && !state->seq_ibld) {
		state->seq_macro_ins_typ = state->seq_typ_bus;
		state->seq_macro_ins_val = state->seq_val_bus;
	}

	if (state_clock && !RNDX(RND_RETRN_LD)) {
		state->seq_retrn_pc_ofs = state->seq_macro_pc_offset;
	}

	if (!bhcke && !state->seq_macro_event) {
		unsigned mode = 0;
		unsigned u = 0;
		if (state->seq_cload) u |= 1;
		if (state->seq_wanna_dispatch) u |= 2;
		switch (u) {
		case 0: mode = 1; break;
		case 1: mode = 1; break;
		case 2:
			if (!state->seq_bad_hint) {
				state->seq_m_pc_mb = RNDX(RND_M_PC_MD0);
			} else {
				state->seq_m_pc_mb = !((state->seq_bhreg >> 2) & 1);
			}

			if (state->seq_m_pc_mb) mode |= 2;
			if (RNDX(RND_M_PC_MD1)) mode |= 1;
			break;
		case 3: mode = 0; break;
		}
		if (mode == 3) {
			uint64_t tmp;
			if (!RNDX(RND_M_PC_MUX)) {
				tmp = state->seq_val_bus;
				state->seq_word = tmp >> 4;
				state->seq_macro_pc_offset = (tmp >> 4) & 0x7fff;
			} else {
				state->seq_macro_pc_offset = branch_offset();
				state->seq_word = state->seq_macro_pc_offset;
			}
		} else if (mode == 2) {
			state->seq_macro_pc_offset += 1;
			state->seq_word += 1;
		} else if (mode == 1) {
			state->seq_macro_pc_offset -= 1;
			state->seq_word += 7;
		}
		state->seq_word &= 7;
	}
	if (state_clock && !RNDX(RND_CUR_LEX)) {
		state->seq_curr_lex = state->seq_val_bus & 0xf;
		state->seq_curr_lex ^= 0xf;
	}

	if (aclk) {
		state->seq_early_macro_pending = mp_macro_event != 0;
		state->seq_emac = mp_macro_event ^ 0x7f;
		if (state->seq_early_macro_pending) {
			state->seq_uadr_decode = 0x0400 + 0x20 * fls(mp_macro_event);
		}
	}
	bool crnana = !(RNDX(RND_INSTR_LD) && dispatch);

	if (sclk) {
		unsigned dsp = 0;
		if (!RNDX(RND_INSTR_MX)) {
			dsp = state->seq_display;
		} else {
			uint64_t tval = state->seq_val_bus;
			dsp = tval & 0xffff;
		}
		dsp ^= 0xffff;;
			
		if (crnana && state->seq_topbot)
			state->seq_ctop = dsp;
		if (crnana && !state->seq_topbot)
			state->seq_cbot = dsp;
	}
			
	if (!bhcke) {
		bool dmdisp = !(!state->seq_bad_hint || (state->seq_bhreg & 0x04));
		bool crnor0a = !(crnana || dmdisp);
		if (!crnor0a)
			state->seq_topbot = !state->seq_topbot;
	}

	if (state->seq_topbot) {
		state->seq_curins = state->seq_cbot;
	} else {
		state->seq_curins = state->seq_ctop;
	}

	if (sclk && !RNDX(RND_BR_MSK_L)) {
		uint64_t tmp = state->seq_val_bus;
		state->seq_break_mask = (tmp >> 16) & 0xffff;
	}

	uint32_t *ciptr;
	if (state->seq_curins & 0xfc00) {
		ciptr = &state->seq_top[state->seq_curins >> 6];
	} else {
		ciptr = &state->seq_bot[state->seq_curins & 0x3ff];
	}

	unsigned ccl = (*ciptr >> 4) & 0xf;

	if (ccl == 0) {
		state->seq_m_break_class = false;
	} else {
		state->seq_m_break_class = (state->seq_break_mask >> (15 - ccl)) & 1;
	}
	state->seq_m_break_class = !state->seq_m_break_class;

	if (state_clock) {
		if (!RNDX(RND_NAME_LD)) {
			state->seq_cur_name = state->seq_typ_bus >> 32;
		}
			
		if (!RNDX(RND_RES_NAME)) {
			state->seq_namram[state->seq_resolve_address] = state->seq_typ_bus >> 32;
		}

		if (!RNDX(RND_RETRN_LD)) {
			state->seq_retseg = state->seq_pcseg;
		}
		if (!RNDX(RND_M_PC_LDH)) {
			//unsigned val;
			//val = state->seq_val_bus >> 32;
			//val ^= 0xffffffff;
			state->seq_pcseg = (~state->seq_val_bus >> 32) & 0xffffff;
		}
		if (!RNDX(RND_SAVE_LD)) {
			state->seq_savrg = state->seq_resolve_offset;
			state->seq_carry_out = state->seq_tmp_carry_out;
		}

		uint64_t cnb;
		if (!RNDX(RND_CNTL_MUX)) {
			cnb = ~state->seq_typ_bus;
		} else {
			cnb = mp_fiu_bus;
		}
		//cnb &= 0xffffffffULL;
		cnb >>= 7;
		cnb &= 0xfffff;

		if (!RNDX(RND_PRED_LD)) {
			state->seq_pred = cnb;
		}
		unsigned csa_cntl = mp_csa_cntl;

		bool ten = (csa_cntl != 2 && csa_cntl != 3);
		bool tud = !(csa_cntl & 1);
		if (!RNDX(RND_TOP_LD)) {
			state->seq_topcnt = cnb;
		} else if (ten) {
			// Nothing
		} else if (tud) {
			state->seq_topcnt += 1;
		} else {
			state->seq_topcnt += 0xfffff;
		}
		state->seq_topcnt &= 0xfffff;
	}

	if (state->seq_s_state_stop && state->seq_l_macro_hic) {
		bool xwrite;
		bool pop;
		unsigned stkinpsel = 0;
		if (!mp_clock_stop_6) {
			xwrite = true;
			pop = true;
			stkinpsel = 3;
		} else if (!state->seq_push) {
			xwrite = true;
			pop = false;
			if (!state->seq_push_br) stkinpsel |= 2;
			if (state->seq_bad_hint) stkinpsel |= 1;
		} else {
			xwrite = !RNDX(RND_PUSH);
			pop = !!(state->seq_preturn || RNDX(RND_POP));
			stkinpsel = 0x1;;
		}

		if (xwrite) {
			switch(stkinpsel) {
			case 0:
				state->seq_topu = UIR_SEQ_BRN;
				if (state->seq_q3cond) state->seq_topu |= (1<<15);
				if (state->seq_latched_cond) state->seq_topu |= (1<<14);
				state->seq_topu ^= 0xffff;
				break;
			case 1:
				state->seq_topu = mp_fiu_bus;
				state->seq_topu &= 0xffff;
				break;
			case 2:
				state->seq_topu = mp_cur_uadr;
				if (state->seq_q3cond) state->seq_topu |= (1<<15);
				if (state->seq_latched_cond) state->seq_topu |= (1<<14);
				state->seq_topu += 1;
				state->seq_topu ^= 0xffff;
				break;
			case 3:
				state->seq_topu = mp_cur_uadr;
				if (state->seq_q3cond) state->seq_topu |= (1<<15);
				if (state->seq_latched_cond) state->seq_topu |= (1<<14);
				state->seq_topu ^= 0xffff;
				break;
			}
		} else if (pop) {
			state->seq_topu = state->seq_ram[state->seq_adr];
		}
		state->seq_saved_latched = !((state->seq_topu >> 14) & 0x1);

		if (RNDX(RND_CLEAR_ST) && !state->seq_stop) {
			state->seq_adr = xwrite;
		} else if (xwrite || pop) {
			if (xwrite) {
				state->seq_adr = (state->seq_adr + 1) & 0xf;
			} else {
				state->seq_adr = (state->seq_adr + 0xf) & 0xf;
			}
		}
		state->seq_stack_size_zero = state->seq_adr == 0;
	}

	if (sclk) {
		state->seq_fiu = mp_fiu_bus;
		state->seq_fiu &= 0x3fff;
	}

	if (aclk) {
		if (!state->seq_maybe_dispatch) {
			state->seq_late_u = 7;
		} else {
			state->seq_late_u = state->seq_lmp;
			if (state->seq_late_u == 8)
				state->seq_late_u = 7;
		}
		unsigned sel = group_sel();
		switch (sel) {
		case 0:
		case 7:
			state->seq_other = mp_cur_uadr + 1;
			break;
		case 1:
		case 2:
		case 3:
			state->seq_other = UIR_SEQ_BRN;
			break;
		case 4:
			state->seq_other = UIR_SEQ_BRN;
			state->seq_other += state->seq_fiu;
			break;
		case 5:
			state->seq_other = state->seq_decode >> 3;
			state->seq_other <<= 1;
			break;
		case 6:
			state->seq_other = (state->seq_topu ^ 0xffff) & 0x3fff;
			break;
		default:
			assert(sel < 8);
			break;
		}
	}

	if (aclk) {
		if (state->seq_check_exit_ue) {
			mp_seq_uev &= ~UEV_CK_EXIT;
		} else {
			mp_seq_uev |= UEV_CK_EXIT;
		}
		if (state->seq_ferr) {
			mp_seq_uev &= ~UEV_FLD_ERR;
		} else {
			mp_seq_uev |= UEV_FLD_ERR;
		}
		if (state->seq_clock_stop_1) {
			mp_seq_uev &= ~UEV_NEW_PAK;
		} else {
			mp_seq_uev |= UEV_NEW_PAK;
		}

		state->seq_uev = 16 - fls(mp_seq_uev);

		if (state->seq_s_state_stop) {
			mp_cur_uadr = mp_nua_bus;
		}

		unsigned adr = 0;
		if (mp_clock_stop_6)
			adr |= 0x02;
		if (!state->seq_macro_event)
			adr |= 0x04;
		adr |= state->seq_br_tim << 3;
		adr |= state->seq_br_type << 5;
		unsigned rom = seq_pa044[adr];

		if (!state_clock) {
			rom |= 0x2;
		} else {
			rom ^= 0x2;
		}
		if (!bhcke) {
			state->seq_bhreg = rom;
		}
			
		state->seq_hint_last = (state->seq_bhreg >> 1) & 1;
		state->seq_hint_t_last = (state->seq_bhreg >> 0) & 1;

		bool bad_hint_disp = (!state->seq_bad_hint || (state->seq_bhreg & 0x08));
		if (state->seq_s_state_stop && state->seq_bad_hint_enable && bad_hint_disp) {
			unsigned restrt_rnd = 0;
			restrt_rnd |= RNDX(RND_RESTRT0) ? 2 : 0;
			restrt_rnd |= RNDX(RND_RESTRT1) ? 1 : 0;
			if (!state->seq_wanna_dispatch) {
				state->seq_rreg = 0xa;
			} else if (restrt_rnd != 0) {
				state->seq_rreg = (restrt_rnd & 0x3) << 1;
			} else {
				state->seq_rreg &= 0xa;
			}
			if (state->seq_macro_event) {
				state->seq_rreg &= ~0x2;
			}
			state->seq_treg = 0x3;
			bool dnan0d = !(dispatch && RNDX(RND_PRED_LD));
			bool tsnor0b = !(dnan0d || state->seq_tos_vld_cond);
			if (tsnor0b)
				state->seq_treg |= 0x8;
			if (!state->seq_tos_vld_cond)
				state->seq_treg |= 0x4;
		} else if (state->seq_s_state_stop && state->seq_bad_hint_enable) {
			state->seq_rreg <<= 1;
			state->seq_rreg &= 0xe;
			state->seq_rreg |= 0x1;
			state->seq_treg <<= 1;
			state->seq_treg &= 0xe;
			state->seq_treg |= 0x1;
		}
		state->seq_rq = state->seq_rreg;
		state->seq_foo7 = state->seq_treg >> 3;

		if (state_clock) {
			unsigned lin = 0;
			lin |= state->seq_latched_cond << 3;
			unsigned condsel = UIR_SEQ_CSEL;
			uint8_t pa042 = seq_pa042[condsel << 2];
			bool is_e_ml = (pa042 >> 7) & 1;
			lin |= is_e_ml << 2;
			lin |= UIR_SEQ_LUIR << 1;
			lin |= state->seq_q3cond << 0;

			state->seq_lreg = lin;
			if (lin & 0x4) {
				state->seq_last_late_cond = state->seq_q3cond;
			}

			switch(state->seq_lreg & 0x6) {
			case 0x0:
			case 0x4:
				state->seq_latched_cond = (state->seq_lreg >> 3) & 1;
				break;
			case 0x2:
				state->seq_latched_cond = (state->seq_lreg >> 0) & 1;
				break;
			case 0x6:
				state->seq_latched_cond = state->seq_last_late_cond;
				break;
			}
		}
	}

	bool last_cond_late = (state->seq_lreg >> 2) & 1;
	if (state->seq_hint_last) {
		state->seq_bad_hint = false;
	} else if (!last_cond_late && !state->seq_hint_t_last) {
		state->seq_bad_hint = state->seq_lreg & 1;
	} else if (!last_cond_late &&  state->seq_hint_t_last) {
		state->seq_bad_hint = !(state->seq_lreg & 1);
	} else if ( last_cond_late && !state->seq_hint_t_last) {
		state->seq_bad_hint = state->seq_last_late_cond;
	} else if ( last_cond_late &&  state->seq_hint_t_last) {
		state->seq_bad_hint = !state->seq_last_late_cond;
	}

	switch(state->seq_word) {
	case 0x0: state->seq_display = state->seq_macro_ins_val >>  0; break;
	case 0x1: state->seq_display = state->seq_macro_ins_val >> 16; break;
	case 0x2: state->seq_display = state->seq_macro_ins_val >> 32; break;
	case 0x3: state->seq_display = state->seq_macro_ins_val >> 48; break;
	case 0x4: state->seq_display = state->seq_macro_ins_typ >>  0; break;
	case 0x5: state->seq_display = state->seq_macro_ins_typ >> 16; break;
	case 0x6: state->seq_display = state->seq_macro_ins_typ >> 32; break;
	case 0x7: state->seq_display = state->seq_macro_ins_typ >> 48; break;
	}
	state->seq_display &= 0xffff;

	if (!state->seq_early_macro_pending) {
		unsigned ai = state->seq_display;
		ai ^= 0xffff;
		bool top = (state->seq_display >> 10) != 0x3f;
		uint32_t *ptr;
		if (top)
			ptr = &state->seq_top[ai >> 6];
		else
			ptr = &state->seq_bot[ai & 0x3ff];
		state->seq_uadr_decode = (*ptr >> 16);
		state->seq_decode = (*ptr >> 8) & 0xff;
	}
	state->seq_uses_tos = (state->seq_uadr_decode >> 2) & 1;
	state->seq_ibuf_fill = (state->seq_uadr_decode >> 1) & 1;
	if (state_clock) {
		state->seq_n_in_csa = mp_csa_nve;
	}
	if (aclk) {
		state->seq_foo9 = !RNDX(RND_TOS_VLB);
	}
	mp_clock_stop_7 = !state->seq_bad_hint && state->seq_l_macro_hic;
	mp_state_clk_en = !(mp_state_clk_stop && mp_clock_stop_7);
	if (!state->seq_sf_stop && mp_seq_prepped) {
		state->seq_uir = state->seq_wcsram[mp_nua_bus] ^ (0x7fULL << 13);	// Invert condsel
		mp_nxt_cond_sel = UIR_SEQ_CSEL;
	}
}


// -------------------- TYP --------------------


bool
r1000_arch ::
bin_op_pass(void)
{
	bool dp = !(TYP_A_BIT(35) && TYP_B_BIT(35));
	bool abim = !(!(TYP_A_BITS(31) == state->typ_ofreg) | dp);
	bool bbim = !(!(TYP_B_BITS(31) == state->typ_ofreg) | dp);

	return (!(
		(abim && bbim) ||
		(bbim && TYP_A_BIT(34)) ||
		(abim && TYP_B_BIT(34)) ||
		(TYP_A_BIT(34) && TYP_A_BIT(35) && TYP_B_BIT(34) && TYP_B_BIT(35))
	));
}

bool
r1000_arch ::
priv_path_eq(void)
{
	return (!(
		(TYP_A_BITS(31) == TYP_B_BITS(31)) &&
		((TYP_A_BITS(56) & 0xfffff) == (TYP_B_BITS(56) & 0xfffff))
	));
}

bool
r1000_arch ::
a_op_pass(void)
{
	return (!(TYP_A_BIT(35) && ((TYP_A_BITS(31) == state->typ_ofreg) || TYP_A_BIT(34))));
}

bool
r1000_arch ::
b_op_pass(void)
{
	return (!(TYP_B_BIT(35) && ((TYP_B_BITS(31) == state->typ_ofreg) || TYP_B_BIT(34))));
}

bool
r1000_arch ::
clev(void)
{
	return (!(
		(!(state->typ_rand != 0x4) && !(TYP_A_LIT() != UIR_TYP_CLIT)) ||
		(!(state->typ_rand != 0x6) && !(TYP_A_LIT() != TYP_B_LIT())) ||
		(!(state->typ_rand != 0x5) && !(TYP_B_LIT() != UIR_TYP_CLIT)) ||
		(!(state->typ_rand != 0x7) && !(TYP_A_LIT() != TYP_B_LIT()) && !(TYP_B_LIT() != UIR_TYP_CLIT))
	));
}

void r1000_arch :: cond_a(bool val) { state->typ_cond = val; mp_condxc = !val; };
void r1000_arch :: cond_b(bool val) { state->typ_cond = val; mp_condxb = !val; };
void r1000_arch :: cond_c(bool val) { state->typ_cond = val; mp_condxa = !val; };
void r1000_arch :: cond_d(bool val) { state->typ_cond = val; mp_condx9 = !val; };
void r1000_arch :: cond_e(bool val) { state->typ_cond = val; mp_condx8 = !val; };

void
r1000_arch ::
typ_cond(unsigned condsel, unsigned when)
{

	if ((condsel >> 3) == 0xb)
		condsel &= ~0x40;

	switch(condsel) {
	case 0x18:	// L - TYP_ALU_ZERO
		cond_a(state->typ_nalu != 0);
		break;
	case 0x19:	// L - TYP_ALU_NONZERO
		cond_a(state->typ_nalu == 0);
		break;
	case 0x1a:	// L - TYP_ALU_A_GT_OR_GE_B
		{
		bool ovrsign = (!(((TYP_A_BIT(0) != TYP_B_BIT(0)) && state->typ_is_binary) || (!state->typ_is_binary && !TYP_A_BIT(0))));
		cond_a(!(
		    ((TYP_A_BIT(0) != TYP_B_BIT(0)) && TYP_A_BIT(0)) ||
		    (state->typ_coh && (ovrsign ^ state->typ_sub_else_add))
		));
		}
		break;
	case 0x1b:	// SPARE
		cond_a(true);
		break;
	case 0x1c:	// E - TYP_LOOP_COUNTER_ZERO
		cond_a(state->typ_count != 0x3ff);
		break;
	case 0x1d:	// SPARE
		cond_a(true);
		break;
	case 0x1e:	// L - TYP_ALU_ZERO - COMBO with VAL_ALU_NONZERO
		cond_a(state->typ_nalu != 0);
		break;
	case 0x1f:	// L - TYP_ALU_32_CO - ALU 32 BIT CARRY OUT
		cond_a(state->typ_com);
		break;
	case 0x20:	// L - TYP_ALU_CARRY
		cond_b(!state->typ_coh);
		break;
	case 0x21:	// L - TYP_ALU_OVERFLOW
		{
		bool ovrsign = (!(((TYP_A_BIT(0) != TYP_B_BIT(0)) && state->typ_is_binary) || (!state->typ_is_binary && !TYP_A_BIT(0))));
		cond_b(state->typ_ovr_en || (
		    state->typ_coh ^ state->typ_almsb ^ state->typ_sub_else_add ^ ovrsign
		));
		}
		break;
	case 0x22:	// L - TYP_ALU_LT_ZERO
		cond_b(state->typ_almsb);
		break;
	case 0x23:	// L - TYP_ALU_LE_ZERO
		cond_b(!(state->typ_almsb && (state->typ_nalu != 0)));
		break;
	case 0x24:	// ML - TYP_SIGN_BITS_EQUAL
		cond_b((TYP_A_BIT(0) != TYP_B_BIT(0)));
		break;
	case 0x25:	// E - TYP_FALSE
		cond_b(true);
		break;
	case 0x26:	// E - TYP_TRUE
		cond_b(false);
		break;
	case 0x27:	// E - TYP_PREVIOUS
		cond_b(state->typ_last_cond);
		break;
	case 0x28:	// ML - OF_KIND_MATCH
		{
		unsigned mask_a = typ_pa059[UIR_TYP_CLIT] >> 1;
		unsigned okpat_a = typ_pa059[UIR_TYP_CLIT + 256] >> 1;
		bool oka = (0x7f ^ (mask_a & TYP_B_LIT())) != okpat_a; // XXX state->typ_b ??

		unsigned mask_b = typ_pa059[UIR_TYP_CLIT + 128] >> 1;
		unsigned okpat_b = typ_pa059[UIR_TYP_CLIT + 384] >> 1;
		bool okb = (0x7f ^ (mask_b & TYP_B_LIT())) != okpat_b;

		bool okm = !(oka & okb);
		cond_c(okm);
		}
		break;
	case 0x29:	// ML - CLASS_A_EQ_LIT
		cond_c(TYP_A_LIT() != UIR_TYP_CLIT);
		break;
	case 0x2a:	// ML - CLASS_B_EQ_LIT
		cond_c(TYP_B_LIT() != UIR_TYP_CLIT);
		break;
	case 0x2b:	// ML - CLASS_A_EQ_B
		cond_c(TYP_A_LIT() != TYP_B_LIT());
		break;
	case 0x2c:	// ML - CLASS_A_B_EQ_LIT
		cond_c(!(TYP_A_LIT() != UIR_TYP_CLIT) || (TYP_B_LIT() != UIR_TYP_CLIT));
		break;
	case 0x2d:	// E - PRIVACY_A_OP_PASS
		cond_c(a_op_pass());
		break;
	case 0x2e:	// ML - PRIVACY_B_OP_PASS
		cond_c(b_op_pass());
		break;
	case 0x2f:	// ML - PRIVACY_BIN_EQ_PASS
		cond_c(priv_path_eq() && bin_op_pass());
		break;
	case 0x30:	// ML - PRIVACY_BIN_OP_PASS
		cond_d(bin_op_pass());
		break;
	case 0x31:	// ML - PRIVACY_NAMES_EQ
		cond_d(TYP_A_BITS(31) == TYP_B_BITS(31));
		break;
	case 0x32:	// ML - PRIVACY_PATHS_EQ
		cond_d(priv_path_eq());
		break;
	case 0x33:	// ML - PRIVACY_STRUCTURE
		cond_d(!(bin_op_pass() || priv_path_eq()));
		break;
	case 0x34:	// E - PASS_PRIVACY_BIT
		cond_d(state->typ_ppriv);
		break;
	case 0x35:	// ML - B_BUS_BIT_32
		cond_d(TYP_B_BIT(32));
		break;
	case 0x36:	// ML - B_BUS_BIT_33
		cond_d(TYP_B_BIT(33));
		break;
	case 0x37:	// ML - B_BUS_BIT_34
		cond_d(TYP_B_BIT(34));
		break;
	case 0x38:	// ML - B_BUS_BIT_35
		cond_e(TYP_B_BIT(35));
		break;
	case 0x39:	// ML - B_BUS_BIT_36
		cond_e(TYP_B_BIT(36));
		break;
	case 0x3a:	// ML - B_BUS_BIT_33_34_OR_36
		cond_e((TYP_B_BITS(36) & 0xd) != 0xd);
		break;
	case 0x3b:	// SPARE
		cond_e(true);
		break;
	case 0x3c:	// SPARE
		cond_e(true);
		break;
	case 0x3d:	// SPARE
		cond_e(true);
		break;
	case 0x3e:	// SPARE
		cond_e(true);
		break;
	case 0x3f:	// ML - B_BUS_BIT_21
		cond_e(TYP_B_BIT(21));
		break;
	}
}

void
r1000_arch ::
typ_find_a(void)
{
	unsigned uira = UIR_TYP_A;
	if (uira == 0x28) {
		state->typ_a = ~0ULL << 10;
		state->typ_a |= state->typ_count;
		return;
	}
	if ((uira & 0x3c) == 0x28) {
		state->typ_a = ~0ULL;
		return;
	}
	state->typ_aadr = 0;
	if (uira == 0x2c) {
		state->typ_aadr = state->typ_count;
	} else if (uira <= 0x1f) {
		state->typ_aadr = state->typ_frm << 5;
		state->typ_aadr |= uira & 0x1f;
	} else if (uira <= 0x2f) {
		state->typ_aadr |= (uira + state->typ_topreg + 1) & 0xf;
	} else {
		state->typ_aadr |= uira & 0x1f;
	}
	state->typ_a = state->typ_rfram[state->typ_aadr];
}

void
r1000_arch ::
typ_find_b(void)
{
	unsigned uirb = UIR_TYP_B;

	state->typ_badr = 0;
	if (uirb == 0x2c) {
		state->typ_badr = state->typ_count;
	} else if (uirb <= 0x1f) {
		state->typ_badr = state->typ_frm << 5;
		state->typ_badr |= uirb & 0x1f;
	} else if (uirb <= 0x27) {
		state->typ_badr |= (uirb + state->typ_topreg + 1) & 0xf;
	} else if (uirb <= 0x2b) {
		unsigned csa = state->typ_botreg + (uirb&1);
		if (!(uirb & 2)) {
			csa += state->typ_csa_offset;
		}
		state->typ_badr |= csa & 0xf;
	} else if (uirb <= 0x2f) {
		state->typ_badr |= (uirb + state->typ_topreg + 1) & 0xf;
	} else {
		state->typ_badr |= uirb & 0x1f;
	}
	if (uirb == 0x29 && mp_typt_oe) {
		state->typ_b = ~mp_typ_bus;
	} else {
		state->typ_b = state->typ_rfram[state->typ_badr];
	}
}

void
r1000_arch ::
typ_h1(void)
{
	state->typ_rand = UIR_TYP_RAND;
	state->typ_frm = UIR_TYP_FRM;

	unsigned marctl = UIR_TYP_MCTL;

	if (mp_fiu_oe == 0x4) {
		typ_find_a();
		mp_fiu_bus = ~state->typ_a;
	}
	if (!mp_typt_oe) {
		typ_find_b();
		mp_typ_bus = ~state->typ_b;
	}
	typ_cond(mp_cond_sel, 0);
	if (mp_adr_oe & 0x6) {
		if (marctl & 0x8) {
			mp_spc_bus = (marctl & 0x7) ^ 0x7;
		} else {
			typ_find_b();
			mp_spc_bus = (state->typ_b & 0x7) ^ 0x7;
		}
	}
}

void
r1000_arch ::
typ_q2(void)
{
	unsigned uirc = UIR_TYP_C;

	unsigned priv_check = UIR_TYP_UPVC;
	if (mp_fiu_oe != 0x4) {
		typ_find_a();
	}
	if (mp_typt_oe) {
		typ_find_b();
	}
	state->typ_wen = (uirc == 0x28 || uirc == 0x29); // LOOP_CNT + DEFAULT
	if (mp_csa_write_enable && uirc != 0x28)
	state->typ_wen = !state->typ_wen;

	bool divide = state->typ_rand != 0xb;
	bool acond = true;
	if (divide && state->typ_last_cond)
		acond = false;
	if (!divide && mp_q_bit) 
		acond = false;
	struct f181 f181l, f181h;
	unsigned tmp, idx, alurand, alufunc = UIR_TYP_AFNC;

	if (state->typ_rand < 8) {
		alurand = 7;
	} else {
		alurand = 15 - state->typ_rand;
	}
	idx = acond << 8;
	idx |= alurand << 5;
	idx |= alufunc;
		
	tmp = typ_pa068[idx];
	state->typ_is_binary = (tmp >> 1) & 1;
	tmp >>= 3;

	f181l.ctl = tmp >> 1;
	f181l.ctl |= (tmp & 1) << 4;
	f181l.ctl |= (state->typ_rand != 0xf) << 5;
	f181l.ci = (typ_pa068[idx] >> 2) & 1;
	f181l.a = state->typ_a & 0xffffffff;
	f181l.b = state->typ_b & 0xffffffff;
	f181_alu(&f181l);
	state->typ_com = f181l.co;
	state->typ_nalu = f181l.o;

	tmp = tv_pa010[idx];
	state->typ_sub_else_add = (tmp >> 2) & 1;
	state->typ_ovr_en = (tmp >> 1) & 1;
	tmp >>= 3;

	f181h.ctl = tmp >> 1;
	f181h.ctl |= (tmp & 1) << 4;
	f181h.ctl |= 1 << 5;
	f181h.ci = f181l.co;
	f181h.a = state->typ_a >> 32;
	f181h.b = state->typ_b >> 32;
	f181_alu(&f181h);
	state->typ_coh = f181h.co;
	state->typ_nalu |= ((uint64_t)f181h.o) << 32;
	state->typ_alu = ~state->typ_nalu;
	state->typ_almsb = state->typ_alu >> 63ULL;

	if (mp_adr_oe & 0x4) {
		uint64_t alu = state->typ_alu;
		unsigned spc = mp_spc_bus;
		if (spc != 4) {
			alu |=0xf8000000ULL;
		}
		mp_adr_bus = ~alu;
	}

	state->typ_cadr = 0;
	if (uirc <= 0x1f) {
		// FRAME:REG
		state->typ_cadr |= uirc & 0x1f;
		state->typ_cadr |= state->typ_frm << 5;
	} else if (uirc <= 0x27) {
		// 0x20 = TOP-1
		// …
		// 0x27 = TOP-8
		state->typ_cadr = (state->typ_topreg + (uirc & 0x7) + 1) & 0xf;
	} else if (uirc == 0x28) {
		// 0x28 LOOP COUNTER (RF write disabled)
	} else if (uirc == 0x29 && mp_csa_write_enable) {
		// 0x29 DEFAULT (RF write disabled)
		unsigned sum = state->typ_botreg + state->typ_csa_offset + 1;
		state->typ_cadr |= sum & 0xf;
	} else if (uirc == 0x29 && !mp_csa_write_enable) {
		// 0x29 DEFAULT (RF write disabled)
		state->typ_cadr |= uirc & 0x1f;
		state->typ_cadr |= state->typ_frm << 5;
	} else if (uirc <= 0x2b) {
		// 0x2a BOT
		// 0x2b BOT-1
		state->typ_cadr |= (state->typ_botreg + (uirc & 1)) & 0xf;
		state->typ_cadr |= (state->typ_botreg + (uirc & 1)) & 0xf;
	} else if (uirc == 0x2c) {
		// 0x28 = LOOP_REG
		state->typ_cadr = state->typ_count;
	} else if (uirc == 0x2d) {
		// 0x2d SPARE
		assert (uirc != 0x2d);
	} else if (uirc <= 0x2f) {
		// 0x2e = TOP+1
		// 0x2f = TOP
		state->typ_cadr = (state->typ_topreg + (uirc & 0x1) + 0xf) & 0xf;
	} else if (uirc <= 0x3f) {
		// GP[0…F]
		state->typ_cadr |= 0x10 | (uirc & 0x0f);
	} else {
		assert(uirc <= 0x3f);
	}

	bool micros_en = mp_uevent_enable;
	mp_clock_stop_3 = true;
	mp_clock_stop_4 = true;
	unsigned selcond = 0x00;
	if (state->typ_ppriv) {
		selcond = 0x80 >> priv_check;
	}
#define TYP_UEV (UEV_CLASS|UEV_BIN_EQ|UEV_BIN_OP|UEV_TOS_OP|UEV_TOS1_OP|UEV_CHK_SYS)
	mp_seq_uev &= ~TYP_UEV;
	if (micros_en) {
		if (selcond == 0x40 && bin_op_pass())
			mp_seq_uev |= UEV_BIN_OP;
		if (selcond == 0x80 && priv_path_eq() && bin_op_pass())
			mp_seq_uev |= UEV_BIN_EQ;
		if ((0x3 < state->typ_rand && state->typ_rand < 0x8) && clev())
			mp_seq_uev |= UEV_CLASS;
		if ((selcond == 0x10 && a_op_pass()) || (selcond == 0x04 && b_op_pass()))
			mp_seq_uev |= UEV_TOS1_OP;
		if ((selcond == 0x20 && a_op_pass()) || (selcond == 0x08 && b_op_pass()))
			mp_seq_uev |= UEV_TOS_OP;
		if ((!((state->typ_rand != 0xe) || !(TYP_B_LIT() != UIR_TYP_CLIT))))
			mp_seq_uev |= UEV_CHK_SYS;

		if ((!((state->typ_rand != 0xe) || !(TYP_B_LIT() != UIR_TYP_CLIT)))) {
			mp_clock_stop_3 = false;
		}

		if ((0x3 < state->typ_rand && state->typ_rand < 0x8) && clev()) {
			mp_clock_stop_3 = false;
		}

		if (priv_path_eq() && bin_op_pass() && selcond == 0x80) {
			mp_clock_stop_3 = false;
		}
	}

	if (selcond == 0x40 && bin_op_pass()) {
		mp_clock_stop_4 = false;
	}

	if ((selcond & 0x30) && a_op_pass()) {
		mp_clock_stop_4 = false;
	}

	if ((selcond & 0x0c) && b_op_pass()) {
		mp_clock_stop_4 = false;
	}
	typ_cond(mp_cond_sel, 0);
	unsigned marctl = UIR_TYP_MCTL;
	if ((mp_adr_oe & 0x6) && marctl < 0x8) {	// XXX: && ?
		mp_spc_bus = (state->typ_b & 0x7) ^ 0x7;
		// XXX: when 4, possible race against address bus truncation in TYP or VAL
	}
}

void
r1000_arch ::
typ_q4(void)
{
	uint64_t c = 0;
	bool chi = false;
	bool clo = false;
	bool uirsclk = !mp_sf_stop;
	bool sclke = (mp_clock_stop && mp_ram_stop && !mp_freeze);
	unsigned priv_check = UIR_TYP_UPVC;
	unsigned uirc = UIR_TYP_C;

	if (uirsclk) {
		state->typ_csa_hit = mp_csa_hit;
		state->typ_csa_write = mp_csa_wr;
		mp_csa_write_enable = !(state->typ_csa_hit || state->typ_csa_write);
	}

	bool c_source = UIR_TYP_CSRC;
	uint64_t fiu = 0;
	bool fiu0, fiu1;
	fiu0 = c_source;
	fiu1 = c_source == (state->typ_rand != 0x3);

	bool sel = UIR_TYP_SEL;

	if (!fiu0 || !fiu1) {
		fiu = ~mp_fiu_bus;
	}
	if (!fiu0) {
		c |= fiu & 0xffffffff00000000ULL;
		chi = true;
	} else {
		if (sel) {
			c |= state->typ_wdr & 0xffffffff00000000ULL;
		} else {
			c |= state->typ_alu & 0xffffffff00000000ULL;
		}
		chi = true;
	}
	if (!fiu1) {
		c |= fiu & 0xffffffffULL;
		clo = true;
	} else {
		if (sel) {
			c |= state->typ_wdr & 0xffffffffULL;
		} else {
			c |= state->typ_alu & 0xffffffffULL;
		}
		clo = true;
	}
	if (chi && !clo)
		c |= 0xffffffff;
	if (!chi && clo)
		c |= 0xffffffffULL << 32;

	bool awe = (!(mp_freeze) && mp_ram_stop);
	if (awe && !state->typ_wen) {
		state->typ_rfram[state->typ_cadr] = c;
	}
	unsigned csmux3 = mp_csa_offs ^ 0xf;
	if (uirsclk) {
		state->typ_csa_offset = csmux3;
	}
	if (sclke) {
		if (!(mp_load_wdr || !(mp_clock_stop_6 && mp_clock_stop_7))) {
			state->typ_wdr = ~mp_typ_bus;
		}
		if (uirc == 0x28) {
			state->typ_count = c;
		} else if (state->typ_rand == 0x2) {
			state->typ_count += 1;
		} else if (state->typ_rand == 0x1) {
			state->typ_count += 0x3ff;
		}
		state->typ_count &= 0x3ff;

		unsigned csmux0;
		if (mp_load_top)
			csmux0 = state->typ_botreg;
		else
			csmux0 = state->typ_topreg;

		unsigned csalu0 = csmux3 + csmux0 + 1;
	
		if (!mp_load_bot)
			state->typ_botreg = csalu0;
		if (!(mp_load_top && mp_pop_down))
			state->typ_topreg = csalu0;
		state->typ_last_cond = state->typ_cond;
		if (state->typ_rand == 0xc) {
			state->typ_ofreg = state->typ_b >> 32;
		}

		if (priv_check != 7) {
			bool set_pass_priv = state->typ_rand != 0xd;
			state->typ_ppriv = set_pass_priv;
		}
	}
	if (uirsclk) {
		state->typ_uir = state->typ_wcsram[mp_nua_bus] ^ 0x7fffc0000000ULL;
		mp_nxt_mar_cntl = UIR_TYP_MCTL;
		mp_nxt_csa_cntl = UIR_TYP_CCTL;
	}
}


// -------------------- VAL --------------------


bool
r1000_arch ::
ovrsgn(void)
{
	bool a0 = state->val_amsb;
	bool b0 = state->val_bmsb;
	bool se = state->val_isbin;
	return (!(
		(se && (a0 ^ b0)) ||
		(!se && !a0)
	));
}

void
r1000_arch ::
val_cond(void)
{
	unsigned csel = mp_cond_sel;
	if ((csel & 0x78) == 0x58)
		csel ^= 0x58;
	switch(csel) {
	case 0x00:	// L VAL_ALU_ZERO
		state->val_thiscond = (state->val_nalu != 0);
		break;
	case 0x01:	// L VAL_ALU_NONZERO
		state->val_thiscond = (state->val_nalu == 0);
		break;
	case 0x02:	// L VAL_ALU_A_LT_OR_LE_B
		state->val_thiscond = !(
			(state->val_bmsb && (state->val_amsb ^ state->val_bmsb)) ||
			(!state->val_coh && (ovrsgn() ^ state->val_sub_else_add))
		);
		break;
	case 0x03:	// SPARE
		state->val_thiscond = true;
		break;
	case 0x04:	// E VAL_LOOP_COUNTER_ZERO
		state->val_thiscond = state->val_count != 0x3ff;
		break;
	case 0x05:	// SPARE
		state->val_thiscond = true;
		break;
	case 0x06:	// L VAL_ALU_NONZERO
		state->val_thiscond = (state->val_nalu == 0);
		break;
	case 0x07:	// L VAL_ALU_32_CO
		state->val_thiscond = state->val_carry_middle;
		break;
	case 0x08:	// L VAL_ALU_CARRY
		state->val_thiscond = !state->val_coh;
		break;
	case 0x09:	// L VAL_ALU_OVERFLOW
		state->val_thiscond = state->val_ovren || !(ovrsgn() ^ state->val_sub_else_add ^ (!state->val_coh) ^ state->val_cmsb);
		break;
	case 0x0a:	// L VAL_ALU_LT_ZERO
		state->val_thiscond = state->val_cmsb;
		break;
	case 0x0b:	// L VAL_ALU_LE_ZERO
		state->val_thiscond = !state->val_cmsb || (state->val_nalu == 0);
		break;
	case 0x0c:	// ML VAL_SIGN_BITS_EQUAL
		state->val_thiscond = (state->val_amsb ^ state->val_bmsb);
		break;
	case 0x0d:	// SPARE
		state->val_thiscond = true;
		break;
	case 0x0e:	// SPARE
		state->val_thiscond = true;
		break;
	case 0x0f:	// E VAL_PREVIOUS
		state->val_thiscond = state->val_last_cond;
		break;
	case 0x10:	// L VAL_ALU_32_ZERO
		state->val_thiscond = (state->val_nalu >> 32);
		break;
	case 0x11:	// L VAL_ALU_40_ZERO
		state->val_thiscond = (state->val_nalu >> 16);
		break;
	case 0x12:	// L VAL_ALU_MIDDLE_ZERO
		state->val_thiscond = (state->val_nalu & 0xffff0000ULL);
		break;
	case 0x13:	// E VAL_Q_BIT
		state->val_thiscond = mp_q_bit;
		break;
	case 0x14:	// SPARE
		state->val_thiscond = true;
		break;
	case 0x15:	// E VAL_M_BIT
		state->val_thiscond = state->val_mbit;
		break;
	case 0x16:	// E VAL_TRUE
		state->val_thiscond = false;
		break;
	case 0x17:	// E VAL_FALSE
		state->val_thiscond = true;
		break;
	default:
		break;
	}
	switch (csel >> 3) {
	case 0x0:
		mp_condxf = !state->val_thiscond;
		break;
	case 0x1:
		mp_condxe = !state->val_thiscond;
		break;
	case 0x2:
		mp_condxd = !state->val_thiscond;
		break;
	default:
		break;
	}
}

bool
r1000_arch ::
fiu_cond(void)
{
	unsigned csel = mp_cond_sel;
	bool fcond;
	switch (csel) {
	case 0x00:
		fcond = state->val_nalu == 0;
		break;
	case 0x01:
		fcond = state->val_nalu != 0;
		break;
	case 0x02:
		if (state->val_amsb ^ state->val_bmsb) {
			fcond = state->val_bmsb;
		} else {
			fcond = !state->val_coh;
		}
		break;
	case 0x0f:
	case 0x16:		// Undocumented
		fcond = state->val_last_cond;
		break;
	default:
		ALWAYS_TRACE(
			<< std::hex << "BAD FIUCOND"
			<< " csel " << csel
		);
		fcond = true;
		// assert(false);
		break;
	}
	return (!fcond);
}

void
r1000_arch ::
val_find_a(void)
{
	unsigned uira = UIR_VAL_A;
	if (uira == 0x28) {
		state->val_a = state->val_count;
		state->val_a |= ~0x3ff;
	} else if (uira == 0x29) {
		unsigned mdst;
		bool prod_16 = state->val_rand != 0xd;
		bool prod_32 = state->val_rand != 0xe;
		mdst = prod_32 << 1;
		mdst |= prod_16;
		switch(mdst) {
		case 0: state->val_a = 0; break;
		case 1: state->val_a = state->val_mprod << 32; break;
		case 2: state->val_a = state->val_mprod << 16; break;
		case 3: state->val_a = state->val_mprod <<  0; break;
		}
		state->val_a = ~state->val_a;
	} else if (uira == 0x2a) {
		state->val_a = state->val_zerocnt;
	} else if (uira == 0x2b) {
		state->val_a = ~0ULL;
	} else {
		unsigned aadr = 0;
		if (uira == 0x2c) {
			aadr = state->val_count;
		} else if (uira <= 0x1f) {
			aadr = UIR_VAL_FRM << 5;
			aadr |= uira & 0x1f;
		} else if (uira <= 0x2f) {
			aadr |= (uira + state->val_topreg + 1) & 0xf;
		} else {
			aadr |= uira & 0x1f;
		}
		state->val_a = state->val_rfram[aadr];
	}
	state->val_amsb = state->val_a >> 63;
}

void
r1000_arch ::
val_find_b(void)
{
	unsigned uirb = UIR_VAL_B;
	bool oe, oe7;
	if (uirb != 0x29) {
		oe = false;
	} else if (!state->val_csa_hit && !mp_valv_oe) { 
		oe = false;
	} else {
		oe = true;
	}

	oe7 = oe || (state->val_rand == 0x6);

	unsigned badr = 0;
	if (!oe || !oe7) {
		if (uirb == 0x2c) {
			badr = state->val_count;
		} else if (uirb <= 0x1f) {
			badr = UIR_VAL_FRM << 5;
			badr |= uirb & 0x1f;
		} else if (uirb <= 0x27) {
			unsigned btos = (uirb & 0xf) + state->val_topreg + 1;
			badr |= btos & 0xf;
		} else if (uirb <= 0x2b) {
			unsigned csa = state->val_botreg + (uirb&1);
			if (!(uirb & 2)) {
				csa += state->val_csa_offset;
			}
			badr |= csa & 0xf;
		} else if (uirb <= 0x2f) {
			unsigned btos = (uirb & 0xf) + state->val_topreg + 1;
			badr |= btos & 0xf;
		} else {
			badr |= uirb & 0x1f;
		}
	}
	state->val_b = 0;
	if (!oe) {
		state->val_b |= state->val_rfram[badr] & ~0xffULL;
	} else {
		state->val_b |= ~mp_val_bus & ~0xffULL;
	}
	if (!oe7) {
		state->val_b |= state->val_rfram[badr] & 0xffULL;
	} else {
		state->val_b |= ~mp_val_bus & 0xffULL;
	}
	state->val_bmsb = state->val_b >> 63;
}
 
void
r1000_arch ::
val_h1(void)
{
	state->val_rand = UIR_VAL_RAND;
	if (mp_fiu_oe == 0x2) {
		val_find_a();
		mp_fiu_bus = ~state->val_a;
	}
	if (!mp_valv_oe) {
		val_find_b();
		mp_val_bus = ~state->val_b;
	}
	val_cond();
}
 
void
r1000_arch ::
val_q2(void)
{

	bool divide = state->val_rand != 0xb;
	unsigned uirc = UIR_VAL_C;
	if (mp_fiu_oe != 0x02) {
		val_find_a();
	}
	if (mp_valv_oe) {
		val_find_b();
	}
	state->val_wen = (uirc == 0x28 || uirc == 0x29); // LOOP_CNT + DEFAULT
	if (state->val_cwe && uirc != 0x28)
		state->val_wen = !state->val_wen;

	state->val_msrc = UIR_VAL_MSRC;
	bool start_mult = state->val_rand != 0xc;
	if (!start_mult) {
		state->val_malat = ~state->val_a;
		state->val_mblat = ~state->val_b;
	}

	struct f181 f181l, f181h;
	unsigned tmp, proma, alur;

	tmp = UIR_VAL_RAND;
	if (tmp < 8) {
		alur = 7;
	} else {
		alur = 15 - tmp;
	}

	proma = UIR_VAL_AFNC;
	proma |= alur << 5;
	if (
		!(
			(state->val_last_cond && divide) ||
			(mp_q_bit && !divide)
		)
	) {
		proma |= 0x100;
	}

	tmp = val_pa011[proma];			// S0-4.LOW
	state->val_isbin = (tmp >> 1) & 1;			// IS_BINARY
	f181l.ctl = (tmp >> 4) & 0xf;
	f181l.ctl |= ((tmp >> 3) & 1) << 4;
	f181l.ctl |= 1 << 5;
	f181l.ci = (val_pa011[proma] >> 2) & 1;	// ALU.C15
	f181l.a = state->val_a & 0xffffffff;
	f181l.b = state->val_b & 0xffffffff;
	f181_alu(&f181l);
	state->val_carry_middle = f181l.co;
	state->val_nalu = f181l.o;

	tmp = tv_pa010[proma];			// S0-4.HIGH
	state->val_ovren = (tmp >> 1) & 1;			// OVR.EN~
	state->val_sub_else_add = (tmp >> 2) & 1;			// SUB_ELSE_ADD
	f181h.ctl = (tmp >> 4) & 0xf;
	f181h.ctl |= ((tmp>>3) & 1) << 4;
	f181h.ctl |= 1 << 5;
	f181h.ci = f181l.co;
	f181h.a = state->val_a >> 32;
	f181h.b = state->val_b >> 32;
	f181_alu(&f181h);
	state->val_coh = f181h.co;
	state->val_nalu |= ((uint64_t)f181h.o) << 32;
	state->val_alu = ~state->val_nalu;
	state->val_cmsb = state->val_alu >> 63;
	if (mp_adr_oe & 0x2) {
		uint64_t alu = state->val_alu;
		// XXX: there is a race here, if TYP gets the space from typ_b only in Q2
		if (mp_spc_bus != 4) {
			alu |=0xf8000000ULL;
		}
		mp_adr_bus = ~alu;
	}

	uint64_t fiu = 0, mux = 0;
	bool c_source = UIR_VAL_CSRC;
	bool split_c_src = state->val_rand == 0x4;
	if (split_c_src || !c_source) {
		fiu = ~mp_fiu_bus;
	}
	if (!c_source && (state->val_rand == 3 || state->val_rand == 6)) {
		fiu &= ~1ULL;
		fiu |= fiu_cond();
	}
	if (c_source || split_c_src) {
		unsigned sel = UIR_VAL_SEL;
		switch (sel) {
		case 0x0:
			mux = state->val_alu << 1;
			mux |= 1;
			break;
		case 0x1:
			mux = state->val_alu >> 16;
			mux |= 0xffffULL << 48;
			break;
		case 0x2:
			mux = state->val_alu;
			break;
		case 0x3:
			mux = state->val_wdr;
			break;
		}
	}
	if (!split_c_src && !c_source) {
		state->val_c = fiu;
	} else if (!split_c_src) {
		state->val_c = mux;
	} else if (c_source) {
		state->val_c = fiu & 0xffffffffULL;
		state->val_c |= mux & 0xffffffffULL << 32;
	} else {
		state->val_c = mux & 0xffffffffULL;
		state->val_c |= fiu & 0xffffffffULL << 32;
	}

	state->val_cadr = 0;
	if (uirc <= 0x1f) {
		// FRAME:REG
		state->val_cadr |= uirc & 0x1f;
		state->val_cadr |= UIR_VAL_FRM << 5;
	} else if (uirc <= 0x27) {
		// 0x20 = TOP-1
		// …
		// 0x27 = TOP-8
		state->val_cadr = (state->val_topreg + (uirc & 0x7) + 1) & 0xf;
	} else if (uirc == 0x28) {
		// 0x28 LOOP COUNTER (RF write disabled)
	} else if (uirc == 0x29 && state->val_cwe) {
		// 0x29 DEFAULT (RF write disabled)
		unsigned sum = state->val_botreg + state->val_csa_offset + 1;
		state->val_cadr |= sum & 0xf;
	} else if (uirc == 0x29 && !state->val_cwe) {
		// 0x29 DEFAULT (RF write disabled)
		state->val_cadr |= uirc & 0x1f;
		state->val_cadr |= UIR_VAL_FRM << 5;
	} else if (uirc <= 0x2b) {
		// 0x2a BOT
		// 0x2b BOT-1
		state->val_cadr |= (state->val_botreg + (uirc & 1)) & 0xf;
		state->val_cadr |= (state->val_botreg + (uirc & 1)) & 0xf;
	} else if (uirc == 0x2c) {
		// 0x28 = LOOP_REG
		state->val_cadr = state->val_count;
	} else if (uirc == 0x2d) {
		// 0x2d SPARE
		assert (uirc != 0x2d);
	} else if (uirc <= 0x2f) {
		// 0x2e = TOP+1
		// 0x2f = TOP
		state->val_cadr = (state->val_topreg + (uirc & 0x1) + 0xf) & 0xf;
	} else if (uirc <= 0x3f) {
		// GP[0…F]
		state->val_cadr |= 0x10 | (uirc & 0x0f);
	} else {
		assert(uirc <= 0x3f);
	}
	val_cond();
}

void
r1000_arch ::
val_q4(void)
{
	bool sclken = (mp_clock_stop && mp_ram_stop && !mp_freeze);
	bool csa_clk = sclken;
	bool uirsclk = !mp_sf_stop;
	bool divide = state->val_rand != 0xb;
	unsigned uirc = UIR_VAL_C;
	if (csa_clk) {
		bool xor0c = state->val_mbit ^ (!state->val_coh);
		bool xor0d = mp_q_bit ^ xor0c;
		bool caoi0b = !(
			((!divide) && xor0d) ||
			(divide && state->val_coh)
		);
		mp_nxt_q_bit = caoi0b;
	}

	if (uirsclk) {
		state->val_csa_hit = mp_csa_hit;
		state->val_csa_write = mp_csa_wr;
		state->val_cwe = !(state->val_csa_hit || state->val_csa_write);
	}

	bool awe = (mp_ram_stop && !mp_freeze);
	if (awe && !state->val_wen) {
		state->val_rfram[state->val_cadr] = state->val_c;
	}
	uint32_t a;
	switch (state->val_msrc >> 2) {
	case 0: a = (state->val_malat >> 48) & 0xffff; break;
	case 1: a = (state->val_malat >> 32) & 0xffff; break;
	case 2: a = (state->val_malat >> 16) & 0xffff; break;
	case 3: a = (state->val_malat >>  0) & 0xffff; break;
	default: assert(false);
	}
	uint32_t b;
	switch (state->val_msrc & 3) {
	case 0: b = (state->val_mblat >> 48) & 0xffff; break;
	case 1: b = (state->val_mblat >> 32) & 0xffff; break;
	case 2: b = (state->val_mblat >> 16) & 0xffff; break;
	case 3: b = (state->val_mblat >>  0) & 0xffff; break;
	default: assert(false);
	}
	state->val_mprod = a * b;
	unsigned csmux3 = mp_csa_offs ^ 0xf;

	if (sclken) {
		if (state->val_rand == 0x5) {
			uint64_t count2 = 0x40 - flsll(~state->val_alu);
			state->val_zerocnt = ~count2;
		}
		if (!(mp_load_wdr || !(mp_clock_stop_6 && mp_clock_stop_7))) {
			state->val_wdr = ~mp_val_bus;
		}
		if (uirc == 0x28) {
			state->val_count = state->val_c;
	} else if (state->val_rand == 0x2 || !divide) {
			state->val_count += 1;
		} else if (state->val_rand == 0x1) {
			state->val_count += 0x3ff;
		}
		state->val_count &= 0x3ff;

		bool bot_mux_sel, top_mux_sel, add_mux_sel;
		bot_mux_sel = mp_load_bot;
		add_mux_sel = mp_load_top;
		top_mux_sel = !(add_mux_sel && mp_pop_down);

		unsigned csmux0;
		if (add_mux_sel)
			csmux0 = state->val_botreg;
		else
			csmux0 = state->val_topreg;

		unsigned csalu0 = csmux3 + csmux0 + 1;

		if (!bot_mux_sel)
			state->val_botreg = csalu0;
		if (top_mux_sel)
			state->val_topreg = csalu0;

		state->val_mbit = state->val_cmsb;
	}
	if (uirsclk) {
		state->val_csa_offset = csmux3;
		state->val_uir = state->val_wcsram[mp_nua_bus] ^ 0xffff800000ULL;
	}
	if (csa_clk)
		state->val_last_cond = state->val_thiscond;
}


// -------------------- IOC --------------------

void
r1000_arch ::
ioc_do_xact(void)
{
	if (!state->ioc_xact)
		state->ioc_xact = ioc_sc_bus_get_xact();

	if (!state->ioc_xact)
		return;

	if (state->ioc_xact->sc_state == 200 && state->ioc_xact->address == 0xfffff100) {
		/* READ GET REQUEST */
		state->ioc_xact->data = state->ioc_reqreg;
		TRACE("RD FIFO GET REQUEST " << std::hex << state->ioc_xact->data);
		ioc_sc_bus_done(&state->ioc_xact);
		return;
	}
	if (state->ioc_xact->sc_state == 100 && state->ioc_xact->address == 0xfffff200) {
		/* WRITE FRONT PANEL */
		TRACE("WR FP " << std::hex << state->ioc_xact->data);
		ioc_sc_bus_done(&state->ioc_xact);
		return;
	}

	if (state->ioc_xact->sc_state == 100 && state->ioc_xact->address == 0xfffff300) {
		/* WRITE SENSE TEST */
		TRACE("WR SENSE TEST " << std::hex << state->ioc_xact->data);
		state->ioc_request_int_en = (state->ioc_xact->data >> 1) & 1;
		state->ioc_response_int_en = (state->ioc_xact->data >> 0) & 1;
		ioc_sc_bus_done(&state->ioc_xact);
		return;
	}
	if (state->ioc_xact->sc_state == 100 && state->ioc_xact->address == 0xfffff400) {
		/* WRITE CONTROL */
		TRACE("WR CONTROL " << std::hex << state->ioc_xact->data);
		state->ioc_fffff400 = (state->ioc_xact->data >> 16) & 0xf;
		ioc_sc_bus_done(&state->ioc_xact);
		return;
	}
	if (state->ioc_xact->sc_state == 100 && state->ioc_xact->address == 0xfffff500) {
		/* WRITE FIFO INIT */
		TRACE("WR FIFO INIT " << std::hex << state->ioc_xact->data);
		state->ioc_reqwrp = state->ioc_reqrdp = 0;
		state->ioc_rspwrp = state->ioc_rsprdp = 0;
		ioc_sc_bus_done(&state->ioc_xact);
		return;
	}

	if (state->ioc_xact->sc_state == 100 && state->ioc_xact->address == 0xfffff600) {
		/* WRITE FIFO CPU RSP */
		TRACE("WR FIFO CPU RSP " << std::hex << state->ioc_xact->data);
		state->ioc_rspfifo[state->ioc_rspwrp++] = state->ioc_xact->data;
		state->ioc_rspwrp &= 0x3ff;

		TRACE(
			"WR FIFO RSP " << std::hex << state->ioc_xact->data
			<< " wr " << state->ioc_rspwrp
			<< " rd " << state->ioc_rsprdp
		);
		ioc_sc_bus_done(&state->ioc_xact);
		return;
	}

	if (state->ioc_xact->sc_state == 100 && state->ioc_xact->address == 0xfffff700) {
		/* WRITE CPU REQUEST */
		state->ioc_reqreg = state->ioc_reqfifo[state->ioc_reqrdp++];
		state->ioc_reqrdp &= 0x3ff;
		TRACE(
			"WR FIFO CPU REQUEST " << std::hex << state->ioc_reqreg
				<< " wr " << state->ioc_reqwrp
				<< " rd " << state->ioc_reqrdp
		);

		ioc_sc_bus_done(&state->ioc_xact);
		return;
	}

	if (state->ioc_xact->sc_state == 200 && state->ioc_xact->address == 0xfffff800) {
		/* READ STATUS */
		state->ioc_xact->data 			   = 0x9000ff80;
		if (state->ioc_cpu_running) {
			state->ioc_xact->data |= 0x40000000;
		}
		// if (PIN_PROTE)			state->ioc_xact->data |= 0x02000000;
		if (state->ioc_fffff400 & 8)	state->ioc_xact->data |= 0x00080000; // IOP.INTR_EN
		if (state->ioc_fffff400 & 4)	state->ioc_xact->data |= 0x00040000; // GOOD_PARITY
		if (state->ioc_fffff400 & 2)	state->ioc_xact->data |= 0x00020000; // PERR_ENABLE
		if (state->ioc_fffff400 & 1)	state->ioc_xact->data |= 0x00010000; // IOP.NEXT_CLK
		state->ioc_xact->data |= 0x7 << 4;
		if (!mp_key_switch)		state->ioc_xact->data |= 0x00000008;
		state->ioc_xact->data |= state->ioc_iack << 0;

		TRACE("RD STATUS " << std::hex << state->ioc_xact->data);
		ioc_sc_bus_done(&state->ioc_xact);
		return;
	}

	if (state->ioc_xact->sc_state == 100 && state->ioc_xact->address == 0xfffff900) {
		/* WRITE CLEAR BERR */
		TRACE("WR CLEAR BERR " << std::hex << state->ioc_xact->data);
		ioc_sc_bus_done(&state->ioc_xact);
		return;
	}
	if (state->ioc_xact->sc_state == 100 && state->ioc_xact->address == 0xfffffe00) {
		/* WRITE CPU CONTROL */
		TRACE("WR CPU CONTROL " << std::hex << state->ioc_xact->data);
		ioc_sc_bus_done(&state->ioc_xact);
		return;
	}
	if (state->ioc_xact->sc_state == 100 && state->ioc_xact->address == 0xfffffd00) {
		TRACE("WR fffffd00" << std::hex << state->ioc_xact->data);
		ioc_sc_bus_done(&state->ioc_xact);
		return;
	}

	TRACE(
		<< "BXPA state= "
		<< state->ioc_xact->sc_state
		<< " adr= "
		<< std::hex << state->ioc_xact->address
		<< " data= "
		<< std::hex << state->ioc_xact->data
		<< " width = "
		<< state->ioc_xact->width
		<< " write= "
		<< state->ioc_xact->is_write
	);
}

bool
r1000_arch ::
ioc_cond(void)
{
	switch (mp_cond_sel) {
	case 0x78:
		return (true); // state->ioc_multibit_error;
		break;
	case 0x79:
		{
		uint64_t tmp = mp_typ_bus & 0x80000047;
		return (tmp == 0x80000000 || tmp == 0x80000040 || tmp == 0x80000044);
		}
		break;
	case 0x7a:
		return (true); // state->ioc_checkbit_error;
		break;
	case 0x7b:
		return (state->ioc_reqwrp != state->ioc_reqrdp);
		break;
	case 0x7c:
		return (state->ioc_acnt == 0xfff);
		break;
	case 0x7d:
		return (true);
		break;
	case 0x7e:
		return (state->ioc_rspwrp != state->ioc_rsprdp);
		break;
	case 0x7f:
		return (true);
		break;
	}
	return (true);
}

void
r1000_arch ::
ioc_h1(void)
{
	if (state->ioc_rspwrp != state->ioc_rsprdp) {
		mp_macro_event |= 0x8;
	} else {
		mp_macro_event &= ~0x8;
	}

	mp_load_wdr = UIR_IOC_ULWDR;

	if (!mp_ioctv_oe) {
		mp_val_bus = state->ioc_dummy_val;

		switch (UIR_IOC_RAND) {
		case 0x05:
			mp_typ_bus = (uint64_t)(state->ioc_slice) << 48;
			mp_typ_bus |= (uint64_t)(state->ioc_delay) << 32;
			mp_typ_bus |= ((uint64_t)state->ioc_rtc) << 16;
			mp_typ_bus |= state->ioc_rspfifo[state->ioc_rsprdp];
			break;
		case 0x08:
		case 0x09:
		case 0x19:
			mp_typ_bus = (uint64_t)(state->ioc_slice) << 48;
			mp_typ_bus |= (uint64_t)(state->ioc_delay) << 32;
			mp_typ_bus |= ((uint64_t)state->ioc_rtc) << 16;
			break;
		case 0x16:
		case 0x1c:
		case 0x1d:
			mp_typ_bus = ((uint64_t)state->ioc_rdata) << 32;
			mp_typ_bus |= ((uint64_t)state->ioc_rtc) << 16;
			break;
		default:
			mp_typ_bus = state->ioc_dummy_typ;
			break;
		}
	}
}

void
r1000_arch ::
ioc_q2(void)
{
	unsigned rand = UIR_IOC_RAND;
	if (state->ioc_slice_ev && !state->ioc_ten) {
		mp_macro_event |= 0x2;
	}
	if (rand == 0x0a) {
		mp_macro_event &= ~0x2;
	}
	if (state->ioc_delay_ev && !state->ioc_ten) {
		mp_macro_event |= 0x1;
	}
	if (rand == 0x0b) {
		mp_macro_event &= ~0x1;
	}
	uint64_t tmp = (mp_typ_bus >> 7) & 0xfffff;
	bool below = (tmp >= 0xc);
	bool exit_proc = rand != 0x12;
	mp_below_tcp = !(below || exit_proc);
}

void
r1000_arch ::
ioc_q4(void)
{
	bool sclk_pos = mp_clock_stop;
	unsigned rand = UIR_IOC_RAND;

	if (mp_ioc_trace && ((mp_sync_freeze & 0x3) == 0) && !state->ioc_is_tracing) {
		state->ioc_is_tracing = true;
		ALWAYS_TRACE(<< " IS TRACING");
	}
	if (mp_ioc_trace && (mp_sync_freeze & 0x3) && state->ioc_is_tracing) {
		state->ioc_is_tracing = true;
		mp_ioc_trace = 0;
		ALWAYS_TRACE(<< " STOP TRACING");
	}

	if ((state->ioc_request_int_en && state->ioc_reqrdp != state->ioc_reqwrp) && state->ioc_iack != 6) {
		state->ioc_iack = 6;
		ioc_sc_bus_start_iack(6);
	}
	if ((!state->ioc_request_int_en || state->ioc_reqrdp == state->ioc_reqwrp) && state->ioc_iack != 7) {
		state->ioc_iack = 7;
		ioc_sc_bus_start_iack(7);
	}

	ioc_do_xact();

	if (sclk_pos) {
		unsigned adr = (state->ioc_areg | state->ioc_acnt) << 2;
		assert(adr < (512<<10));

		switch(rand) {
		case 0x01:
			state->ioc_acnt = (mp_typ_bus >> 2) & 0x00fff;
			state->ioc_areg = (mp_typ_bus >> 2) & 0x1f000;
			break;
		case 0x04:
			state->ioc_reqfifo[state->ioc_reqwrp++] = mp_typ_bus & 0xffff;
			state->ioc_reqwrp &= 0x3ff;
			break;
		case 0x05:
			state->ioc_rsprdp++;
			state->ioc_rsprdp &= 0x3ff;
			break;
		case 0x08:
			state->ioc_rtc = 0;
			break;
		case 0x0c:
			state->ioc_sen = false;
			break;
		case 0x0d:
			state->ioc_sen = true;
			break;
		case 0x0e:
			state->ioc_den = false;
			break;
		case 0x0f:
			state->ioc_den = true;
			break;
		case 0x1c:
			state->ioc_rdata = vbe32dec(state->ioc_ram + adr);
			state->ioc_acnt += 1;
			state->ioc_acnt &= 0xfff;
			break;
		case 0x1d:
			state->ioc_rdata = vbe32dec(state->ioc_ram + adr);
			break;
		case 0x1e:
			vbe32enc(state->ioc_ram + adr, mp_typ_bus >> 32);
			state->ioc_acnt += 1;
			state->ioc_acnt &= 0xfff;
			break;
		case 0x1f:
			vbe32enc(state->ioc_ram + adr, mp_typ_bus >> 32);
			break;
		case 0x23:
			state->ioc_cpu_running = true;
			break;
		case 0x24:
			state->ioc_cpu_running = false;
			break;
		default:
			break;
		}
	}

	if (!mp_sf_stop && rand != 0x08) {
		state->ioc_rtc++;
		state->ioc_rtc &= 0xffff;
	}
								
	state->ioc_prescaler++;
	state->ioc_ten = state->ioc_prescaler != 0xf;
	state->ioc_prescaler &= 0xf;

	state->ioc_slice_ev = state->ioc_slice == 0xffff;
	if (rand == 0x06) {
		uint64_t tmp = mp_typ_bus;
		tmp >>= 32;
		state->ioc_slice = tmp >> 16;
		TRACE(<< " LD " << std::hex << state->ioc_slice);
	} else 	if (!state->ioc_sen && !state->ioc_ten) {
		state->ioc_slice++;
	}

	state->ioc_delay_ev= state->ioc_delay == 0xffff;
	if (rand == 0x07) {
		uint64_t tmp = mp_typ_bus;
		tmp >>= 32;
		state->ioc_delay = tmp;
	} else if (!state->ioc_den && !state->ioc_ten) {
		state->ioc_delay++;
	}
	bool rddum = (UIR_IOC_TVBS < 0xc) || !state->ioc_dumen;
	if (rddum && !mp_restore_rdr) {
		state->ioc_dummy_typ = mp_typ_bus;
		state->ioc_dummy_val = mp_val_bus;
	}

	if (!mp_sf_stop) {
		state->ioc_uir = state->ioc_wcsram[mp_nua_bus];
		assert (state->ioc_uir <= 0xffff);
		mp_nxt_adr_oe = 1 << UIR_IOC_AEN;
		mp_nxt_fiu_oe = 1 << UIR_IOC_FEN;
		state->ioc_dumen = !mp_dummy_next;
		state->ioc_csa_hit = !mp_csa_hit;
		unsigned tvbs = UIR_IOC_TVBS;

		uint16_t tdat = mp_nua_bus;
		if (!sclk_pos)
			tdat |= 0x8000;
		if (state->ioc_csa_hit)
			tdat |= 0x4000;
		uint16_t tptr = state->ioc_tram[2048];
		state->ioc_tram[tptr] = tdat;
		if (mp_ioc_trace) {
			tptr += 1;
			tptr &= 0x7ff;
			state->ioc_tram[2048] = tptr;
		}
		mp_nxt_seqtv_oe = true;
		mp_nxt_fiuv_oe = true;
		mp_nxt_fiut_oe = true;
		mp_nxt_memv_oe = true;
		mp_nxt_memtv_oe = true;
		mp_nxt_ioctv_oe = true;
		mp_nxt_valv_oe = true;
		mp_nxt_typt_oe = true;
		switch (tvbs) {
		case 0x0: mp_nxt_valv_oe = false; mp_nxt_typt_oe = false; break;
		case 0x1: mp_nxt_fiuv_oe = false; mp_nxt_typt_oe = false; break;
		case 0x2: mp_nxt_valv_oe = false; mp_nxt_fiut_oe = false; break;
		case 0x3: mp_nxt_fiuv_oe = false; mp_nxt_fiut_oe = false; break;
		case 0x4: mp_nxt_ioctv_oe = false; break;
		case 0x5: mp_nxt_seqtv_oe = false; break;
		case 0x8:
		case 0x9:
			mp_nxt_memv_oe = false; mp_nxt_typt_oe = false; break;
		case 0xa:
		case 0xb:
			mp_nxt_memv_oe = false; mp_nxt_fiut_oe = false; break;
		case 0xc:
		case 0xd:
		case 0xe:
		case 0xf:
			if (state->ioc_dumen) {
				mp_nxt_ioctv_oe = false;
			} else if (state->ioc_csa_hit) {
				mp_nxt_typt_oe = false;
				mp_nxt_valv_oe = false;
			} else {
				mp_nxt_memtv_oe = false;
				mp_nxt_memv_oe = false;
			}
			break;
		default:
			break;
		}
	}
}
